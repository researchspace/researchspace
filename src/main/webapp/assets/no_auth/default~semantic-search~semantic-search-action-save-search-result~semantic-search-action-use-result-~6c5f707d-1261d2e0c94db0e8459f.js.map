{"version":3,"sources":["webpack:///./src/main/web/components/semantic/search/data/search/Model.ts","webpack:///./src/main/web/components/semantic/search/data/Common.ts","webpack:///./src/main/web/components/semantic/search/data/profiles/Model.ts"],"names":["Resource","Resources","isEntityDisjunct","disjunct","_","includes","keys","EntityDisjunctKinds","kind","isTemporalDisjunct","TemporalDisjunctKinds","isSpatialDisjunct","SpatialDisjunctKinds","isLiteralDisjunct","LiteralDisjunctKind","isNumericRangeDisjunct","NumericRangeDisjunctKind","isTextDisjunct","TextDisjunctKind","matchEntityDisjunct","matcher","Set","Search","SavedSearch","matchTemporalDisjunct","Date","DateRange","DateDeviation","Year","YearRange","YearDeviation","matchSpatialDisjunct","Distance","BoundingBox","Category","Relation","Categories","Relations","RelationKey","AvailableDomains","ConjunctKinds","Text","matchConjunct","conjunct","isSetDisjunct","matchDisjunct","bindingToEntity","binding","iriBindingName","labelBindingName","iri","Entity","tuple","label","value","Record","bindingsToEntities","bindings","entities","map","List","transformRangePattern","pattern","range","rangeTo","clonedPattern","cloneDeep","visitor","findSecondVariable","args","variable","find","hasVariable","some","getBindPattern","expression","type","filter","operator","rangeVariables","begin","end","rangeToVariables","this","QueryVisitor","forEach","p","console","warn","JSON","stringify","_value","equals","other","domain","hashCode","hash","Rdf","smi","Key","key"],"mappings":"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","file":"default~semantic-search~semantic-search-action-save-search-result~semantic-search-action-use-result-~6c5f707d-1261d2e0c94db0e8459f.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as moment from 'moment';\nimport * as _ from 'lodash';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { Resource } from '../Common';\nexport { Resource, Resources } from '../Common';\n\nimport { Category, Relation } from '../profiles/Model';\nexport { Category, Relation, Categories, Relations, RelationKey, AvailableDomains } from '../profiles/Model';\n\nexport interface Search {\n  readonly domain: Category;\n  readonly conjuncts: Conjuncts;\n}\n\nexport type Conjunct = RelationConjunct | TextConjunct;\nexport type Conjuncts = Array<Conjunct>;\n\nexport type ConjunctIndex = Array<number>;\nexport type DisjunctIndex = Array<number>;\n\nexport const ConjunctKinds: {\n  Relation: 'Relation';\n  Text: 'Text';\n} = {\n  Relation: 'Relation',\n  Text: 'Text',\n};\nexport type ConjunctKind = typeof ConjunctKinds.Relation | typeof ConjunctKinds.Text;\nexport interface RelationConjunct<D = RelationDisjunct> {\n  readonly kind: typeof ConjunctKinds.Relation;\n  readonly relation: Relation;\n  conjunctIndex: ConjunctIndex;\n  uniqueId?: number;\n  readonly range: Category;\n  readonly disjuncts: Array<D>;\n}\n\nexport interface TextConjunct {\n  readonly kind: typeof ConjunctKinds.Text;\n  conjunctIndex: ConjunctIndex;\n  uniqueId?: number;\n  readonly range: Category;\n  readonly disjuncts: Array<TextDisjunct>;\n}\n\nexport type Disjunct = RelationDisjunct | TextDisjunct;\nexport type Disjuncts = Array<Disjunct>;\n\nexport type RelationDisjunct =\n  | EntityDisjunct\n  | TemporalDisjunct\n  | SpatialDisjunct\n  | LiteralDisjunct\n  | NumericRangeDisjunct;\n\nexport type EntityDisjunct = ResourceDisjunct | SetDisjunct | SavedSearchDisjunct | SearchDisjunct;\n\nexport type TemporalDisjunct =\n  | DateDisjunct\n  | DateRangeDisjunct\n  | DateDeviationDisjunct\n  | YearDisjunct\n  | YearRangeDisjunct\n  | YearDeviationDisjunct;\n\nexport type DateDisjunctValue = DateValue | DateRange | DateDeviation | YearValue | YearRange | YearDeviation;\n\nexport type SpatialDisjunct = SpatialDistanceDisjunct | SpatialBoundingBoxDisjunct;\n\nexport const EntityDisjunctKinds: {\n  Resource: 'Resource';\n  Set: 'Set';\n  SavedSearch: 'SavedSearch';\n  Search: 'Search';\n} = {\n  Resource: 'Resource',\n  Set: 'Set',\n  SavedSearch: 'SavedSearch',\n  Search: 'Search',\n};\nexport const TextDisjunctKind = 'Text';\nexport const TemporalDisjunctKinds: {\n  Date: 'Date';\n  DateRange: 'DateRange';\n  DateDeviation: 'DateDeviation';\n  Year: 'Year';\n  YearRange: 'YearRange';\n  YearDeviation: 'YearDeviation';\n} = {\n  Date: 'Date',\n  DateRange: 'DateRange',\n  DateDeviation: 'DateDeviation',\n  Year: 'Year',\n  YearRange: 'YearRange',\n  YearDeviation: 'YearDeviation',\n};\n\nexport const SpatialDisjunctKinds: {\n  Distance: 'Distance';\n  BoundingBox: 'BoundingBox';\n} = {\n  Distance: 'Distance',\n  BoundingBox: 'BoundingBox',\n};\n\nexport const LiteralDisjunctKind = 'Literal';\nexport const NumericRangeDisjunctKind = 'NumericRange';\n\nexport interface ResourceDisjunct extends AbstractDisjunct<Resource> {\n  readonly kind: typeof EntityDisjunctKinds.Resource;\n}\nexport interface SetDisjunct extends AbstractDisjunct<Resource> {\n  readonly kind: typeof EntityDisjunctKinds.Set;\n}\n\nexport interface SavedSearchValue {\n  query: SparqlJs.SelectQuery;\n  label: string;\n}\n\nexport interface SavedSearchDisjunct extends AbstractDisjunct<SavedSearchValue> {\n  readonly kind: typeof EntityDisjunctKinds.SavedSearch;\n}\nexport interface SearchDisjunct extends AbstractDisjunct<Search> {\n  readonly kind: typeof EntityDisjunctKinds.Search;\n}\nexport interface TextDisjunct extends AbstractDisjunct<string> {\n  readonly kind: typeof TextDisjunctKind;\n}\n\nexport interface DateDisjunct extends AbstractDisjunct<DateValue> {\n  readonly kind: typeof TemporalDisjunctKinds.Date;\n}\nexport interface DateRangeDisjunct extends AbstractDisjunct<DateRange> {\n  readonly kind: typeof TemporalDisjunctKinds.DateRange;\n}\nexport interface DateDeviationDisjunct extends AbstractDisjunct<DateDeviation> {\n  readonly kind: typeof TemporalDisjunctKinds.DateDeviation;\n}\nexport interface YearDisjunct extends AbstractDisjunct<YearValue> {\n  readonly kind: typeof TemporalDisjunctKinds.Year;\n}\nexport interface YearRangeDisjunct extends AbstractDisjunct<YearRange> {\n  readonly kind: typeof TemporalDisjunctKinds.YearRange;\n}\nexport interface YearDeviationDisjunct extends AbstractDisjunct<YearDeviation> {\n  readonly kind: typeof TemporalDisjunctKinds.YearDeviation;\n}\n\nexport interface SpatialDistanceDisjunct extends AbstractDisjunct<SpatialDistance> {\n  readonly kind: typeof SpatialDisjunctKinds.Distance;\n}\nexport interface SpatialBoundingBoxDisjunct extends AbstractDisjunct<SpatialBoundingBox> {\n  readonly kind: typeof SpatialDisjunctKinds.BoundingBox;\n}\n\nexport interface LiteralDisjunct extends AbstractDisjunct<Literal> {\n  readonly kind: typeof LiteralDisjunctKind;\n}\nexport interface NumericRangeDisjunct extends AbstractDisjunct<NumericRange> {\n  readonly kind: typeof NumericRangeDisjunctKind;\n}\n\nexport type DateValue = moment.Moment;\nexport interface DateRange {\n  readonly begin: DateValue;\n  readonly end: DateValue;\n}\nexport interface DateDeviation {\n  readonly date: DateValue;\n  readonly deviation: number;\n}\nexport interface YearValue {\n  readonly year: number;\n  readonly epoch: string;\n}\nexport interface YearRange {\n  readonly begin: YearValue;\n  readonly end: YearValue;\n}\nexport interface YearDeviation {\n  readonly year: YearValue;\n  readonly deviation: number;\n}\n\n// coordinate is always expected in WGS-84 coordinate system\nexport interface Coordinate {\n  lat: number;\n  long: number;\n}\n\nexport interface SpatialDistance {\n  readonly center: Coordinate;\n  readonly distance: any;\n}\n\nexport interface SpatialBoundingBox {\n  readonly southWest: Coordinate;\n  readonly northEast: Coordinate;\n}\n\nexport interface Literal {\n  readonly literal: Rdf.Literal;\n}\nexport interface NumericRange {\n  readonly begin: number;\n  readonly end: number;\n}\n\ninterface AbstractDisjunct<T> {\n  disjunctIndex: DisjunctIndex;\n  readonly kind: DisjunctKind;\n  readonly value: T;\n}\n\nexport type DisjunctKind =\n  | EntityDisjunctKind\n  | TemporalDisjunctT\n  | SpatialDisjunctKind\n  | typeof TextDisjunctKind\n  | typeof LiteralDisjunctKind\n  | typeof NumericRangeDisjunctKind;\nexport type EntityDisjunctKind =\n  | typeof EntityDisjunctKinds.Resource\n  | typeof EntityDisjunctKinds.Set\n  | typeof EntityDisjunctKinds.Search\n  | typeof EntityDisjunctKinds.SavedSearch;\nexport type TemporalDisjunctT =\n  | typeof TemporalDisjunctKinds.Date\n  | typeof TemporalDisjunctKinds.DateRange\n  | typeof TemporalDisjunctKinds.DateDeviation\n  | typeof TemporalDisjunctKinds.Year\n  | typeof TemporalDisjunctKinds.YearRange\n  | typeof TemporalDisjunctKinds.YearDeviation;\nexport type SpatialDisjunctKind = typeof SpatialDisjunctKinds.Distance | typeof SpatialDisjunctKinds.BoundingBox;\n\n// matchers\nexport interface ConjunctMatcher<T> {\n  Relation: (conjunct: RelationConjunct) => T;\n  Text: (conjunct: TextConjunct) => T;\n}\nexport function matchConjunct<T>(matcher: ConjunctMatcher<T>) {\n  return function (conjunct: Conjunct) {\n    switch (conjunct.kind) {\n      case ConjunctKinds.Relation:\n        return matcher[ConjunctKinds.Relation](conjunct);\n      case ConjunctKinds.Text:\n        return matcher[ConjunctKinds.Text](conjunct);\n    }\n  };\n}\n\nexport function isEntityDisjunct(disjunct: Disjunct): disjunct is EntityDisjunct {\n  return _.includes(_.keys(EntityDisjunctKinds), disjunct.kind);\n}\n\nexport function isTemporalDisjunct(disjunct: Disjunct): disjunct is TemporalDisjunct {\n  return _.includes(_.keys(TemporalDisjunctKinds), disjunct.kind);\n}\n\nexport function isSpatialDisjunct(disjunct: Disjunct): disjunct is SpatialDisjunct {\n  return _.includes(_.keys(SpatialDisjunctKinds), disjunct.kind);\n}\n\nexport function isLiteralDisjunct(disjunct: Disjunct): disjunct is LiteralDisjunct {\n  return disjunct.kind === LiteralDisjunctKind;\n}\n\nexport function isNumericRangeDisjunct(disjunct: Disjunct): disjunct is NumericRangeDisjunct {\n  return disjunct.kind === NumericRangeDisjunctKind;\n}\n\nexport function isTextDisjunct(disjunct: Disjunct): disjunct is TextDisjunct {\n  return disjunct.kind === TextDisjunctKind;\n}\n\nexport function isSetDisjunct(disjunct: Disjunct): disjunct is SetDisjunct {\n  return disjunct.kind === EntityDisjunctKinds.Set;\n}\nexport interface DisjunctMatcher<T>\n  extends EntityDisjunctMatcher<T>,\n    TemporalDisjunctMatcher<T>,\n    SpatialDisjunctMatcher<T>,\n    TextDisjunctMatcher<T>,\n    LiteralDisjunctMatcher<T>,\n    NumericRangeDisjunctMatcher<T> {}\n\nexport interface TextDisjunctMatcher<T> {\n  Text: (disjunct: TextDisjunct) => T;\n}\nexport interface LiteralDisjunctMatcher<T> {\n  Literal: (disjunct: LiteralDisjunct) => T;\n}\nexport interface NumericRangeDisjunctMatcher<T> {\n  NumericRange: (disjunct: NumericRangeDisjunct) => T;\n}\n\nexport function matchDisjunct<T>(matcher: DisjunctMatcher<T>) {\n  return function (disjunct: Disjunct) {\n    if (isTextDisjunct(disjunct)) {\n      return matcher[TextDisjunctKind](disjunct);\n    } else if (isEntityDisjunct(disjunct)) {\n      return matchEntityDisjunct(matcher)(disjunct);\n    } else if (isTemporalDisjunct(disjunct)) {\n      return matchTemporalDisjunct(matcher)(disjunct);\n    } else if (isSpatialDisjunct(disjunct)) {\n      return matchSpatialDisjunct(matcher)(disjunct);\n    } else if (isLiteralDisjunct(disjunct)) {\n      return matcher[LiteralDisjunctKind](disjunct);\n    } else if (isNumericRangeDisjunct(disjunct)) {\n      return matcher[NumericRangeDisjunctKind](disjunct);\n    }\n  };\n}\n\nexport interface EntityDisjunctMatcher<T> {\n  Resource: (disjunct: ResourceDisjunct) => T;\n  Set: (disjunct: SetDisjunct) => T;\n  SavedSearch: (disjunct: SavedSearchDisjunct) => T;\n  Search: (disjunct: SearchDisjunct) => T;\n}\nexport function matchEntityDisjunct<T>(matcher: EntityDisjunctMatcher<T>) {\n  return function (disjunct: EntityDisjunct) {\n    switch (disjunct.kind) {\n      case EntityDisjunctKinds.Resource:\n        return matcher[EntityDisjunctKinds.Resource](disjunct);\n      case EntityDisjunctKinds.Set:\n        return matcher[EntityDisjunctKinds.Set](disjunct);\n      case EntityDisjunctKinds.Search:\n        return matcher[EntityDisjunctKinds.Search](disjunct);\n      case EntityDisjunctKinds.SavedSearch:\n        return matcher[EntityDisjunctKinds.SavedSearch](disjunct);\n    }\n  };\n}\n\nexport interface TemporalDisjunctMatcher<T> {\n  Date: (disjunct: DateDisjunct) => T;\n  DateRange: (disjunct: DateRangeDisjunct) => T;\n  DateDeviation: (disjunct: DateDeviationDisjunct) => T;\n  Year: (disjunct: YearDisjunct) => T;\n  YearRange: (disjunct: YearRangeDisjunct) => T;\n  YearDeviation: (disjunct: YearDeviationDisjunct) => T;\n}\nexport function matchTemporalDisjunct<T>(matcher: TemporalDisjunctMatcher<T>) {\n  return function (disjunct: TemporalDisjunct) {\n    switch (disjunct.kind) {\n      case TemporalDisjunctKinds.Date:\n        return matcher[TemporalDisjunctKinds.Date](disjunct);\n      case TemporalDisjunctKinds.DateRange:\n        return matcher[TemporalDisjunctKinds.DateRange](disjunct);\n      case TemporalDisjunctKinds.DateDeviation:\n        return matcher[TemporalDisjunctKinds.DateDeviation](disjunct);\n      case TemporalDisjunctKinds.Year:\n        return matcher[TemporalDisjunctKinds.Year](disjunct);\n      case TemporalDisjunctKinds.YearRange:\n        return matcher[TemporalDisjunctKinds.YearRange](disjunct);\n      case TemporalDisjunctKinds.YearDeviation:\n        return matcher[TemporalDisjunctKinds.YearDeviation](disjunct);\n    }\n  };\n}\n\nexport interface SpatialDisjunctMatcher<T> {\n  Distance: (disjunct: SpatialDistanceDisjunct) => T;\n  BoundingBox: (disjunct: SpatialBoundingBoxDisjunct) => T;\n}\nexport function matchSpatialDisjunct<T>(matcher: SpatialDisjunctMatcher<T>) {\n  return function (disjunct: SpatialDisjunct) {\n    switch (disjunct.kind) {\n      case SpatialDisjunctKinds.Distance:\n        return matcher[SpatialDisjunctKinds.Distance](disjunct);\n      case SpatialDisjunctKinds.BoundingBox:\n        return matcher[SpatialDisjunctKinds.BoundingBox](disjunct);\n    }\n  };\n}\n\nexport interface GraphScopeSearch {\n  translationId: string;\n  keywords: string;\n}\n\nexport interface GraphScopeResults {\n  relations: Array<{ domain: string; range: string; relation: { iri: string; label: string } }>;\n  columns: ReadonlyArray<GraphScopeColumn>;\n  /** variableName looks like this: ?v0 (0...n) */\n  cardinality: ReadonlyArray<{ [variableName: string]: number }>;\n}\n\nexport type GraphScopeColumn = GraphScopeConceptColumn | GraphScopeValueColumn;\ninterface GraphScopeColumnBase {\n  id: string;\n  tgConcept: { iri: string; label: string; color: string };\n}\nexport interface GraphScopeConceptColumn extends GraphScopeColumnBase {\n  type: 'var-concept';\n  attributes: ReadonlyArray<GraphScopeValueColumn>;\n}\nexport interface GraphScopeValueColumn extends GraphScopeColumnBase {\n  type: 'var-value';\n  attribute: {\n    /** Datatype IRIs in <>, e.g. <http://example.com/foo> */\n    iri: string;\n    label: string;\n    matched: boolean;\n  };\n  datatype: string;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { OrderedMap } from 'immutable';\nimport * as _ from 'lodash';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient, QueryVisitor } from 'platform/api/sparql';\n\nexport interface Resource {\n  readonly iri: Rdf.Iri;\n  readonly label: string;\n  readonly description?: string;\n  readonly tuple: SparqlClient.Binding;\n}\nexport type Resources = OrderedMap<Rdf.Iri, Resource>;\n\nimport { Record, List } from 'immutable';\n\nexport interface EntityI {\n  iri: Rdf.Iri;\n  label: string;\n  tuple: SparqlClient.Binding;\n}\n\nexport type Entity = Record.IRecord<EntityI>;\nexport type Entities = List<Entity>;\nexport const Entity = Record<EntityI>({\n  iri: null,\n  label: null,\n  tuple: null,\n});\n\nexport function bindingsToEntities(\n  bindings: SparqlClient.Bindings,\n  iriBindingName: string,\n  labelBindingName: string\n): List<Entity> {\n  var entities = _.map(bindings, (binding) => bindingToEntity(binding, iriBindingName, labelBindingName));\n  return List(entities);\n}\n\nexport function bindingToEntity(\n  binding: SparqlClient.Binding,\n  iriBindingName: string,\n  labelBindingName: string\n): Entity {\n  var iri = binding[iriBindingName];\n  return Entity({\n    tuple: binding,\n    iri: <Rdf.Iri>iri,\n    label: binding[labelBindingName].value,\n  });\n}\n\nexport type ValueRange = { begin: string; end: string };\n\n/**\n * Replaces filters which restrict ranges with bind patterns.\n *\n * @example\n * {\n *    $subject ?__relation__ ?date .\n *    ?date crm:P82a_begin_of_the_begin ?begin ;\n *      crm:P82b_end_of_the_end ?end .\n *    FILTER(?begin <= ?__dateEndValue__) .\n *    FILTER(?end >= ?__dateBeginValue__) .\n * }\n *\n * // result:\n * {\n *    $subject ?__relation__ ?date .\n *    ?date crm:P82a_begin_of_the_begin ?begin ;\n *      crm:P82b_end_of_the_end ?end .\n *    BIND(?begin as ?dateEndValue) .\n *    BIND(?end as ?dateBeginValue) .\n * }\n */\nexport function transformRangePattern(pattern: SparqlJs.Pattern[], range: ValueRange, rangeTo: ValueRange) {\n  const clonedPattern = _.cloneDeep(pattern);\n\n  // Replace range filter patterns with bind patterns\n  // Find variables names in the ranges filters\n  const visitor = new (class extends QueryVisitor {\n    public begin: SparqlJs.Term;\n    public end: SparqlJs.Term;\n\n    private findSecondVariable(args: SparqlJs.Expression[], variable: string) {\n      return _.find(args, (value) => value !== variable) as SparqlJs.Term;\n    }\n\n    private hasVariable(args: SparqlJs.Expression[], variable: string): boolean {\n      return _.some(args, (value) => value === variable);\n    }\n\n    private getBindPattern(variable: SparqlJs.Term, expression: SparqlJs.Expression): SparqlJs.BindPattern {\n      return { type: 'bind', variable, expression };\n    }\n\n    filter(pattern: SparqlJs.FilterPattern): SparqlJs.Pattern {\n      const { type, operator, args } = pattern.expression as SparqlJs.OperationExpression;\n\n      if (type !== 'operation') {\n        return super.filter(pattern);\n      }\n\n      const rangeVariables = {\n        begin: `?${range.begin}` as SparqlJs.Term,\n        end: `?${range.end}` as SparqlJs.Term,\n      };\n      const rangeToVariables = {\n        begin: `?${rangeTo.begin}` as SparqlJs.Term,\n        end: `?${rangeTo.end}` as SparqlJs.Term,\n      };\n\n      if (operator === '>=' && this.hasVariable(args, rangeVariables.begin)) {\n        this.end = this.findSecondVariable(args, rangeVariables.begin);\n        return this.getBindPattern(rangeToVariables.end, this.end);\n      }\n\n      if (operator === '<=' && this.hasVariable(args, rangeVariables.end)) {\n        this.begin = this.findSecondVariable(args, rangeVariables.end);\n        return this.getBindPattern(rangeToVariables.begin, this.begin);\n      }\n\n      return super.filter(pattern);\n    }\n  })();\n\n  clonedPattern.forEach((p) => visitor.pattern(p));\n\n  if (!visitor.begin || !visitor.end) {\n    console.warn(\n      'The following query pattern',\n      JSON.stringify(pattern),\n      \"can't be automatically used for selection of facet values,\",\n      'pattern is expected to have two FILTERs which restrict ranges.'\n    );\n  }\n\n  return clonedPattern;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, © Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { OrderedMap, Map } from 'immutable';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { Resource } from '../Common';\n\nexport interface Category extends Resource {\n  readonly thumbnail?: string;\n  readonly color?: string;\n}\nexport type Categories = OrderedMap<Rdf.Iri, Category>;\nexport interface Relation extends Resource {\n  readonly hasRange: Category;\n  readonly hasDomain: Category;\n  available?: boolean;\n  hashCode: () => number;\n  equals: (other: Relation) => boolean;\n}\nexport type Relations = OrderedMap<RelationKey.Key, Relation>;\n\nexport interface Profile extends Resource {\n  readonly categories: Categories;\n  readonly relations: Relations;\n}\nexport type Profiles = Map<Rdf.Iri, Profile>;\n\nexport module RelationKey {\n  export interface Value {\n    iri: Rdf.Iri;\n    domain: Rdf.Iri;\n    range: Rdf.Iri;\n  }\n\n  export class Key {\n    constructor(private _value: Value) {}\n\n    get value() {\n      return this._value;\n    }\n\n    public equals(other: Key) {\n      return (\n        this.value.iri.equals(other.value.iri) &&\n        this.value.domain.equals(other.value.domain) &&\n        this.value.range.equals(other.value.range)\n      );\n    }\n\n    public hashCode() {\n      let hash = 0;\n      hash = 31 * hash + this.value.iri.hashCode();\n      hash = 31 * hash + this.value.domain.hashCode();\n      hash = 31 * hash + this.value.range.hashCode();\n      return Rdf.smi(hash);\n    }\n  }\n\n  export function key(value: Value) {\n    return new Key(value);\n  }\n}\n\nexport type AvailableDomains = Map<Rdf.Iri, string>;\n"],"sourceRoot":""}