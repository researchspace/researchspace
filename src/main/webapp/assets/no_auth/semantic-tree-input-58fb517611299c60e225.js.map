{"version":3,"sources":["webpack:///./src/main/web/components/semantic/lazy-tree/SemanticTreeInput.ts","webpack:///./src/main/web/components/semantic/lazy-tree/TreeSelection.ts","webpack:///./src/main/web/components/semantic/lazy-tree/KeyedForest.ts","webpack:///./src/main/web/components/semantic/lazy-tree/SelectionMode.ts","webpack:///./src/main/web/components/semantic/lazy-tree/NodeModel.ts","webpack:///./src/main/web/components/semantic/lazy-tree/SparqlNodeModel.ts","webpack:///./src/main/web/components/semantic/lazy-tree/GraphAlgorithms.ts","webpack:///./src/main/web/components/semantic/lazy-tree/LazyTreeSelector.tsx"],"names":["props","context","cancellation","Cancellation","search","derive","setInitialSelection","initialSelection","length","map","LabelsService","getLabels","flatMap","labels","bindings","iri","item","label","has","Rdf","literal","get","undefined","hasChildren","restoreTreeFromLeafNodes","observe","value","forest","confirmedSelection","setState","error","console","state","createQueryModel","mode","type","Node","readyToLoadForest","TreeSelection","empty","emptyForest","componentDidMount","this","componentWillReceiveProps","nextProps","rootsQuery","childrenQuery","parentsQuery","searchQuery","model","SparqlNodeModel","SparqlUtil","parseQuerySync","limit","sparqlOptions","semanticContext","loadError","componentWillUnmount","cancelAll","render","D","div","className","classnames","styles","holder","createElement","ErrorNotification","errorMessage","result","ref","overlayHolder","inputAndButtons","renderTextField","renderBrowseButton","renderOverlay","droppable","Droppable","query","dropStyles","dropComponents","components","onDrop","drop","setValue","getLabel","onValue","newSelection","setToSingleTerminal","searchText","searching","searchResult","onSelectionChanged","textFieldProps","input","textInput","inputClassName","placeholder","onFocus","searchInputFocused","openDropdownOnFocus","selection","onBlur","closeDropdown","saveSelection","onChange","e","searchFor","currentTarget","onKeyDown","keyCode","onClear","selectedItems","leafs","sortBy","onSelectionClick","ClearableInput","RemovableBadge","key","title","onClick","onRemove","previous","unselect","keyOf","toArray","text","force","hasEnoughSearchText","allowForceSuggestion","searchForce","deriveAndCancel","performSearch","parametrized","SparqlClient","setBindings","__token__","makeLuceneQuery","Kefir","later","select","results","matchedCount","matchLimit","OverlayTrigger","placement","overlay","Tooltip","id","Button","browseButton","active","modeType","span","options","newState","Overlay","show","container","target","findDOMNode","OverlayProxy","dropdown","renderDropdownContent","renderDropdownFooter","updateForest","displayingSearch","update","callback","_","assign","searchMessage","Spinner","searchSpinner","renderScrollableDropdownContent","limitMessage","root","children","tree","renderTree","enableSelectionSave","dropdownFooter","dropdownButton","bsStyle","disabled","inSearchMode","renderedForest","searchTerm","toLowerCase","config","isLeaf","hasMoreChildren","childrenOf","loading","hasMoreItems","renderItem","node","requestMore","path","getKeyPath","requestChildren","selectionMode","multipleSelection","MultipleFullSubtrees","SingleFullSubtree","closeDropdownOnSelection","isExpanded","expanded","onExpandedOrCollapsed","updateNode","TreeNode","set","LazyTreeSelector","highlightedTerm","parts","startIndex","indexOf","endIndex","substring","highlighted","isSearching","changePromise","loadingForest","forestChange","change","score","isIri","isLiteral","certainlyLeaf","parseFloat","reachedLimit","filter","loadFromLeafs","transitiveReduction","treeRoot","KeyedForest","create","sealLazyExpanding","Component","SemanticTreeInput","Children","only","SelectionNode","isTerminal","parent","addedPath","slice","selectedBranch","nodes","Set","find","candidate","getParent","shift","addedNode","reduceRight","updateChildren","makeTerminal","removeChildren","reduce","acc","selectTerminal","lastNode","excludeNode","child","base","emptyRoot","setRoot","isRoot","toList","nodesFromKey","current","size","unselectedNode","first","pathToRemove","getNodePath","removedNode","pop","reverse","selectAndCollapseToTerminal","subtree","withSubtree","every","materializeAndExclude","defaultSelectedSubtree","parentPath","targetKey","materializeTerminalChildren","fromKeyPath","getParentPath","Error","forestNode","selectionNode","leaveParentSelected","childOfParent","parentKey","currentParent","mutableNodes","Immutable","Map","asMutable","mutableParents","index","computeMappingAndPaths","mutableMapping","forEach","existing","items","add","asImmutable","parents","getFirst","reference","unshift","childKey","getChildIndex","candidates","mapRoot","updateNodeAt","removeNode","lastKeyIndex","splice","pathIndex","mapBottomUp","mapper","mapNode","CheckState","singleFullSubtree","renderSelected","itemSelection","defaultSelection","Full","Partial","None","multipleFullSubtrees","FullGreyedOut","multiplePartialSubtrees","itemKey","MultiplePartialSubtrees","partialSubtrees","isSelectedSubtree","Boolean","isSubtreeRoot","getSelectedSubtrees","roots","push","findSubtreeParent","itemPath","findSubtreeInPath","keyPath","PartialSubtrees","queryMoreChildren","loadChildren","constant","r","loaded","currentForest","mergeRemovingDuplicates","oldNodes","newNodes","existingKeys","Object","loadPath","shouldLoadChildren","latest","loadedPath","repeat","constantError","takeErrors","last","toProperty","expandPath","expandNode","nextPathIndex","rootKey","readyToLoadRoot","params","loadMoreChildren","hasLimit","offset","queryResult","nodesFromQueryResult","flatMapErrors","initialChildren","initialOrphans","List","groupBy","group","restoreGraphFromLeafs","stream","emitter","onResult","unresolvedOrphans","keys","disposed","onError","end","request","orphanKeys","prepareParsedQuery","requested","parentLabel","delete","existingNode","parentOrphan","requestedKey","emit","Array","from","values","orphan","graph","breakGraphCycles","asImmutableForest","orderBy","COMPARE_BY_SCORE_THEN_BY_LABEL","total","sum","findRoots","loadParent","parameters","binding","nodeLabel","sealed","visiting","visited","edgesToRemove","toVisit","clear","searchForRedundantEdges","currentChild","grandChild","EntryType","VirtualizedList","renderRow","rowProps","isScrolling","style","entry","entries","renderedEntry","renderEntry","rowStyle","paddingLeft","depth","onRowsRendered","info","overscanStartIndex","overscanStopIndex","requestItemsWithVisibleAnchors","indices","list","forceUpdateGrid","scrollToPath","rowIndex","scrollToRow","itemHeight","renderEmpty","component","AutoSizer","width","height","virtualizedList","rowCount","overscanRowCount","rowHeight","Math","max","noRowsRenderer","rowRenderer","overflowX","overflowY","containerStyle","maxWidth","minHeight","Anchor","spinnerDelay","spinner","start","min","i","checkState","itemExpanded","itemCollapsed","expandToggle","visibility","toggleExpanded","onItemClick","hideCheckboxes","checked","onItemCheckedChange","indeterminate","itemContent","previouslyExpanded","event","next","defaultProps","computeEntries","describeChildren","withMutations","mapping","parentSelection","output","childIndex","describeItem","isItemExpanded","expandedByDefault"],"mappings":"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","file":"semantic-tree-input-58fb517611299c60e225.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { ReactElement, createElement, ReactNode, Children, Props as ReactProps } from 'react';\nimport * as D from 'react-dom-factories';\nimport { findDOMNode } from 'react-dom';\nimport { List } from 'immutable';\nimport * as Kefir from 'kefir';\nimport * as _ from 'lodash';\nimport { Overlay, Button, Tooltip, OverlayTrigger } from 'react-bootstrap';\nimport * as SparqlJs from 'sparqljs';\nimport * as classnames from 'classnames';\n\nimport { Cancellation } from 'platform/api/async';\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlUtil, SparqlClient } from 'platform/api/sparql';\nimport * as LabelsService from 'platform/api/services/resource-label';\nimport { Component } from 'platform/api/components';\nimport { ErrorNotification } from 'platform/components/ui/notification';\nimport { ClearableInput, ClearableInputProps, RemovableBadge } from 'platform/components/ui/inputs';\nimport { Spinner } from 'platform/components/ui/spinner';\nimport { Droppable } from 'platform/components/dnd';\n\nimport { KeyedForest, KeyPath } from './KeyedForest';\nimport { TreeSelection, SelectionNode } from './TreeSelection';\nimport { SingleFullSubtree, MultipleFullSubtrees } from './SelectionMode';\nimport { TreeNode, ForestChange, queryMoreChildren } from './NodeModel';\nimport { Node, SparqlNodeModel, sealLazyExpanding } from './SparqlNodeModel';\nimport { LazyTreeSelector, LazyTreeSelectorProps } from './LazyTreeSelector';\n\nimport * as styles from './SemanticTreeInput.scss';\n\nexport interface ComplexTreePatterns {\n  /**\n   * Tree roots query with no input and [?item, ?label, ?hasChildren] output variables.\n   */\n  rootsQuery: string;\n  /**\n   * Children query with [?parent] input and [?item, ?label, ?hasChildren] output variables.\n   */\n  childrenQuery: string;\n  /**\n   * Parent nodes query with [?item] inputs through VALUES(...) clause\n   * and [?item, ?parent, ?parentLabel] outputs.\n   */\n  parentsQuery: string;\n  /**\n   * Search query with [?__token__] input and [?item, ?score, ?label, ?hasChildren] outputs.\n   */\n  searchQuery: string;\n}\n\nexport interface SemanticTreeInputProps extends ComplexTreePatterns {\n  /**\n   * Optional custom class for the tree.\n   */\n  className?: string;\n\n  /**\n   * This component is an uncontrolled component, but this property can be used to specify\n   * array of nodes that should be initially selected.\n   */\n  initialSelection?: ReadonlyArray<Rdf.Iri>;\n\n  /** Allows to drop entity if it satisfies ASK-query */\n  droppable?: {\n    query: string;\n    styles?: {\n      enabled: any;\n      disabled: any;\n    };\n    components?: {\n      disabledHover?: any;\n    };\n  };\n  /** Allows to select multiple items at the same time. */\n  multipleSelection?: boolean;\n  /** Empty field placeholder. */\n  placeholder?: string;\n  /** Callback invoked when tree selection changes. */\n  onSelectionChanged?: (selection: TreeSelection<Node>) => void;\n  /** Callback invoked when user clicks on selected item badge. */\n  onSelectionClick?: (selection: TreeSelection<Node>, node: SelectionNode<Node>) => void;\n  /** Automatically open/close dropdown in full mode when input focused/blurred. */\n  openDropdownOnFocus?: boolean;\n  /** Allow forced search with query less than MIN_SEARCH_TERM_LENGTH by pressing Enter **/\n  allowForceSuggestion?: boolean;\n\n  /**\n   * Closes the dropdown when some value is selected.\n   *\n   * @default false\n   */\n  closeDropdownOnSelection?: boolean;\n}\n\nconst ITEMS_LIMIT = 200;\nconst MIN_SEARCH_TERM_LENGTH = 3;\nconst SEARCH_DELAY_MS = 300;\n\ninterface State {\n  forest?: KeyedForest<Node>;\n\n  loadError?: any;\n  model?: SparqlNodeModel;\n  searchQuery?: SparqlJs.SelectQuery;\n\n  confirmedSelection?: TreeSelection<Node>;\n\n  searchInputFocused?: boolean;\n  searchText?: string;\n  searchForce?: boolean;\n  searching?: boolean;\n  searchResult?: SearchResult;\n\n  mode?: DropdownMode;\n}\n\ntype DropdownMode = { type: 'collapsed' } | ExpandedMode;\ntype ExpandedMode = {\n  type: 'full' | 'search';\n  selection: TreeSelection<Node>;\n};\n\ninterface SearchResult {\n  forest?: KeyedForest<Node>;\n  error?: any;\n  matchedCount?: number;\n  matchLimit?: number;\n}\n\n/**\n * Tree selector component that allows the user to navigate the tree\n * along a broader/narrower relationship (e.g. parent/child).\n *\n * @example\n *\n * <semantic-tree-input placeholder='Select or search for a place...'\n *\n * roots-query='\n *   prefix skos: <http://www.w3.org/2004/02/skos/core#>\n *   select distinct ?item ?label ?hasChildren where {\n *     {\n *       ?item a <http://www.cidoc-crm.org/cidoc-crm/E53_Place>\n *       MINUS { ?item skos:broader ?parent }\n *       OPTIONAL { ?item skos:prefLabel ?label }\n *     }\n *     OPTIONAL {\n *       ?child skos:broader ?item .\n *       ?child a <http://www.cidoc-crm.org/cidoc-crm/E53_Place>\n *     }\n *     BIND(bound(?child) as ?hasChildren)\n *   } order by ?label\n * '\n *\n * children-query='\n *   prefix skos: <http://www.w3.org/2004/02/skos/core#>\n *   select distinct ?item ?label ?hasChildren where {\n *     {\n *       ?item a <http://www.cidoc-crm.org/cidoc-crm/E53_Place> .\n *       ?item skos:broader ?parent\n *       OPTIONAL { ?item skos:prefLabel ?label }\n *     }\n *     OPTIONAL {\n *       ?child skos:broader ?item .\n *       ?child a <http://www.cidoc-crm.org/cidoc-crm/E53_Place>\n *     }\n *     BIND(bound(?child) as ?hasChildren)\n *   } order by ?label\n * '\n *\n * parents-query='\n *   prefix skos: <http://www.w3.org/2004/02/skos/core#>\n *   select distinct ?item ?parent ?parentLabel where {\n *     ?item skos:broader ?parent .\n *     OPTIONAL { ?parent skos:prefLabel ?parentLabel }\n *   }\n * '\n *\n * search-query='\n *   prefix bds: <http://www.bigdata.com/rdf/search#>\n *   prefix skos: <http://www.w3.org/2004/02/skos/core#>\n *   select distinct ?item ?score ?label ?hasChildren where {\n *     SERVICE <http://www.bigdata.com/rdf/search#search> {\n *       ?label bds:search ?__token__ ;\n *         bds:relevance ?score .\n *     }\n *     ?item a <http://www.cidoc-crm.org/cidoc-crm/E53_Place> .\n *     ?item skos:prefLabel ?label\n *     OPTIONAL {\n *       ?child skos:broader ?item .\n *       ?child a <http://www.cidoc-crm.org/cidoc-crm/E53_Place>\n *     }\n *     BIND(bound(?child) as ?hasChildren)\n *   } order by ?score limit 100\n * '></semantic-tree-input>\n */\nexport class SemanticTreeInput extends Component<SemanticTreeInputProps, State> {\n  private readonly cancellation = new Cancellation();\n  private search = this.cancellation.derive();\n\n  private overlayHolder: HTMLElement;\n  private textInput: ClearableInput;\n\n  constructor(props: SemanticTreeInputProps, context: any) {\n    super(props, context);\n    this.state = {\n      ...this.createQueryModel(this.props),\n      mode: { type: 'collapsed' },\n      forest: Node.readyToLoadForest,\n      confirmedSelection: TreeSelection.empty(Node.emptyForest),\n    };\n  }\n\n  componentDidMount() {\n    this.setInitialSelection();\n  }\n\n  componentWillReceiveProps(nextProps: SemanticTreeInputProps) {\n    const props = this.props;\n    const sameQueries =\n      props.rootsQuery === nextProps.rootsQuery &&\n      props.childrenQuery === nextProps.childrenQuery &&\n      props.parentsQuery === nextProps.parentsQuery &&\n      props.searchQuery === nextProps.searchQuery;\n    if (!sameQueries) {\n      this.setState(this.createQueryModel(nextProps));\n    }\n  }\n\n  private createQueryModel(props: SemanticTreeInputProps): State {\n    try {\n      const model = new SparqlNodeModel({\n        rootsQuery: SparqlUtil.parseQuerySync<SparqlJs.SelectQuery>(props.rootsQuery),\n        childrenQuery: SparqlUtil.parseQuerySync<SparqlJs.SelectQuery>(props.childrenQuery),\n        parentsQuery: SparqlUtil.parseQuerySync<SparqlJs.SelectQuery>(props.parentsQuery),\n        limit: ITEMS_LIMIT,\n        sparqlOptions: () => ({ context: this.context.semanticContext }),\n      });\n      const searchQuery = SparqlUtil.parseQuerySync<SparqlJs.SelectQuery>(props.searchQuery);\n      return { model, searchQuery };\n    } catch (loadError) {\n      return { loadError };\n    }\n  }\n\n  /**\n   * To set initial selection we first need to restore the full path from the\n   * selected items to the root, we use the same mechanism as we use in search.\n   * But in addition to that we also need to fetch labels for selected items using LabelsService.\n   */\n  private setInitialSelection = () => {\n    const { initialSelection } = this.props;\n    if (!initialSelection || initialSelection.length === 0) {\n      return;\n    }\n    this.cancellation\n      .map(LabelsService.getLabels(initialSelection))\n      .flatMap((labels) => {\n        const bindings = initialSelection.map((iri) => ({\n          item: iri,\n          label: labels.has(iri) ? Rdf.literal(labels.get(iri)) : undefined,\n          hasChildren: Rdf.literal(true),\n        }));\n        return this.restoreTreeFromLeafNodes(bindings);\n      })\n      .observe({\n        value: (forest) => {\n          const confirmedSelection = forest as TreeSelection<Node>;\n          this.setState({ confirmedSelection });\n        },\n        error: (error) => console.error('Failed to restore initial tree selection', error),\n      });\n  };\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n  }\n\n  render() {\n    if (this.state.loadError) {\n      return D.div(\n        { className: classnames(styles.holder, this.props.className) },\n        createElement(ErrorNotification, { errorMessage: this.state.loadError })\n      );\n    } else {\n      const result = D.div(\n        {\n          ref: (holder) => (this.overlayHolder = holder),\n          className: classnames(styles.holder, this.props.className),\n        },\n        D.div({ className: styles.inputAndButtons }, this.renderTextField(), this.renderBrowseButton()),\n        this.renderOverlay()\n      );\n      if (this.props.droppable) {\n        return createElement(\n          Droppable,\n          {\n            query: this.props.droppable.query,\n            dropStyles: this.props.droppable.styles,\n            dropComponents: {\n              ...this.props.droppable.components,\n            },\n            onDrop: (drop: Rdf.Iri) => {\n              this.setValue(drop);\n            },\n          },\n          result\n        );\n      } else {\n        return result;\n      }\n    }\n  }\n\n  private setValue(iri: Rdf.Iri) {\n    this.cancellation.map(LabelsService.getLabel(iri)).onValue((label) => {\n      const newSelection = TreeSelection.setToSingleTerminal(TreeSelection.empty(this.state.forest), {\n        iri,\n        label: Rdf.literal(label),\n      });\n      this.setState(\n        {\n          mode: { type: 'collapsed' },\n          searchText: undefined,\n          searching: false,\n          searchResult: undefined,\n          confirmedSelection: newSelection,\n        },\n        () => {\n          if (this.props.onSelectionChanged) {\n            this.props.onSelectionChanged(this.state.confirmedSelection);\n          }\n        }\n      );\n    });\n  }\n\n  private renderTextField() {\n    const textFieldProps: ClearableInputProps & ReactProps<ClearableInput> = {\n      ref: (input) => (this.textInput = input),\n      className: styles.textInput,\n      inputClassName: styles.input,\n      value: this.state.searchText || '',\n      placeholder: this.props.placeholder,\n      onFocus: () =>\n        this.setState({\n          searchInputFocused: true,\n          mode:\n            this.state.mode.type === 'collapsed' && this.props.openDropdownOnFocus\n              ? { type: 'full', selection: this.state.confirmedSelection }\n              : this.state.mode,\n        }),\n      onBlur: () => {\n        this.setState({ searchInputFocused: false });\n        if (!this.state.searchText && !this.props.openDropdownOnFocus) {\n          this.closeDropdown({ saveSelection: false });\n        }\n      },\n      onChange: (e) => this.searchFor(e.currentTarget.value, false),\n      onKeyDown: (e) => {\n        if (e.keyCode === 13 && this.state.searchInputFocused) {\n          // enter\n          this.searchFor(this.state.searchText, true);\n        }\n      },\n      onClear: () => {\n        if (this.state.searchInputFocused || this.state.searchText) {\n          this.closeDropdown({ saveSelection: false });\n        }\n      },\n    };\n\n    const selection = this.state.confirmedSelection;\n    const selectedItems = TreeSelection.leafs(selection).sortBy((item) => item.label.value);\n\n    const { onSelectionClick } = this.props;\n    return createElement(\n      ClearableInput,\n      textFieldProps,\n      selectedItems\n        .map((item) =>\n          createElement(\n            RemovableBadge,\n            {\n              key: item.iri.value,\n              title: item.iri.value,\n              onClick: onSelectionClick ? () => onSelectionClick(selection, item) : undefined,\n              onRemove: () => {\n                const previous = this.state.confirmedSelection;\n                const newSelection = TreeSelection.unselect(previous, previous.keyOf(item));\n                this.setState({ confirmedSelection: newSelection }, () => {\n                  if (this.props.onSelectionChanged) {\n                    this.props.onSelectionChanged(newSelection);\n                  }\n                });\n              },\n            },\n            item.label.value\n          )\n        )\n        .toArray()\n    );\n  }\n\n  private searchFor(text: string, force: boolean) {\n    const doForceSearch = this.props.allowForceSuggestion && force;\n    const hasEnoughSearchText = doForceSearch || text.length >= MIN_SEARCH_TERM_LENGTH;\n\n    if (hasEnoughSearchText) {\n      const searchingSameText = this.state.searching && this.state.searchText === text;\n      if (!searchingSameText) {\n        this.setState({\n          searchText: text,\n          searchForce: force,\n          searching: hasEnoughSearchText,\n          mode: { type: 'search', selection: this.state.confirmedSelection },\n        });\n\n        this.search = this.cancellation.deriveAndCancel(this.search);\n        this.search.map(this.performSearch(text)).observe({\n          value: (searchResult) => this.setState({ searchResult, searching: false }),\n          error: (error) => this.setState({ searchResult: { error }, searching: false }),\n        });\n      }\n    } else {\n      this.search.cancelAll();\n\n      let mode = this.state.mode;\n      if (text.length === 0 && !this.props.openDropdownOnFocus) {\n        mode = { type: 'collapsed' };\n      } else if (text.length > 0) {\n        mode = { type: 'search', selection: this.state.confirmedSelection };\n      }\n      this.setState({\n        mode,\n        searchText: text,\n        searchForce: force,\n      });\n    }\n  }\n\n  private performSearch(text: string) {\n    const parametrized = SparqlClient.setBindings(this.state.searchQuery, {\n      __token__: SparqlUtil.makeLuceneQuery(text),\n    });\n    return Kefir.later(SEARCH_DELAY_MS, {})\n      .flatMap<SparqlClient.SparqlSelectResult>(() => SparqlClient.select(parametrized))\n      .flatMap<SearchResult>((result) =>\n        this.restoreTreeFromLeafNodes(result.results.bindings).map((forest) => ({\n          forest,\n          matchedCount: result.results.bindings.length,\n          matchLimit: parametrized.limit,\n        }))\n      );\n  }\n\n  renderBrowseButton() {\n    return createElement(\n      OverlayTrigger,\n      {\n        placement: 'bottom',\n        overlay: createElement(\n          Tooltip,\n          {\n            id: 'SemanticTreeInput__tooltip',\n          },\n          'Browse full hierarchy'\n        ),\n      },\n      createElement(\n        Button,\n        {\n          className: styles.browseButton,\n          active: this.state.mode.type === 'full',\n          onClick: () => {\n            const modeType = this.state.mode.type;\n            if (modeType === 'collapsed' || modeType === 'search') {\n              this.search.cancelAll();\n              this.setState({\n                searchText: undefined,\n                searching: false,\n                searchResult: undefined,\n                mode: { type: 'full', selection: this.state.confirmedSelection },\n              });\n            } else if (modeType === 'full') {\n              this.closeDropdown({ saveSelection: false });\n            }\n          },\n        },\n        D.span({\n          className: 'fa fa-sitemap fa-lg',\n          ['aria-hidden' as any]: true,\n        })\n      )\n    );\n  }\n\n  private closeDropdown(options: { saveSelection: boolean }) {\n    this.search.cancelAll();\n    this.setState(\n      (state: State, props: SemanticTreeInputProps): State => {\n        const mode = state.mode;\n        const newState: State = {\n          mode: { type: 'collapsed' },\n          searchText: undefined,\n          searching: false,\n          searchResult: undefined,\n        };\n        if (mode.type !== 'collapsed' && options.saveSelection) {\n          newState.confirmedSelection = mode.selection;\n          if (props.onSelectionChanged) {\n            props.onSelectionChanged(mode.selection);\n          }\n        }\n        return newState;\n      }\n    );\n  }\n\n  private renderOverlay() {\n    const mode = this.state.mode;\n    return createElement(\n      Overlay,\n      {\n        show: mode.type !== 'collapsed',\n        placement: 'bottom',\n        container: this.overlayHolder,\n        target: () => findDOMNode(this.textInput),\n      },\n      // use proxy component for overlay content to avoid warnings\n      // about unknown props provided by React.Bootstrap\n      createElement(\n        OverlayProxy,\n        {},\n        mode.type === 'collapsed'\n          ? D.div({})\n          : D.div({ className: styles.dropdown }, this.renderDropdownContent(mode), this.renderDropdownFooter(mode))\n      )\n    );\n  }\n\n  private updateForest(\n    displayingSearch: boolean,\n    update: (forest: KeyedForest<Node>, state: State, props: SemanticTreeInputProps) => KeyedForest<Node>,\n    callback?: () => void\n  ) {\n    this.setState((state: State, props: SemanticTreeInputProps): State => {\n      if (displayingSearch) {\n        return {\n          searchResult: _.assign({}, state.searchResult, {\n            forest: update(state.searchResult.forest, state, props),\n          }),\n        };\n      } else {\n        return { forest: update(state.forest, state, props) };\n      }\n    }, callback);\n  }\n\n  private renderDropdownContent(mode: ExpandedMode): ReactElement<any> {\n    if (mode.type === 'search') {\n      if (\n        this.state.searchText.length < MIN_SEARCH_TERM_LENGTH &&\n        (!this.state.searchForce || !this.props.allowForceSuggestion)\n      ) {\n        return D.span(\n          { className: styles.searchMessage },\n          `Minimum length of search term is ${MIN_SEARCH_TERM_LENGTH} characters.`\n        );\n      } else if (this.state.searching) {\n        return createElement(Spinner, { className: styles.searchSpinner });\n      } else if (this.state.searchResult.error) {\n        return createElement(ErrorNotification, { errorMessage: this.state.searchResult.error });\n      }\n    }\n    return this.renderScrollableDropdownContent(mode);\n  }\n\n  private renderScrollableDropdownContent(mode: ExpandedMode): ReactElement<any> {\n    let limitMessage: ReactElement<any> = null;\n    let noResultsMessage: ReactElement<any> = null;\n\n    if (mode.type === 'search') {\n      const { matchedCount, matchLimit, forest } = this.state.searchResult;\n      if (matchLimit && matchedCount === matchLimit) {\n        limitMessage = D.span(\n          { className: styles.searchMessage },\n          `Only first ${matchedCount} matches are shown. Please refine your search.`\n        );\n      } else if (!forest.root.children || forest.root.children.length === 0) {\n        return D.span({ className: styles.searchMessage }, `No results found.`);\n      }\n    }\n\n    return D.div({ className: styles.tree }, this.renderTree(mode), limitMessage);\n  }\n\n  private renderDropdownFooter(mode: ExpandedMode) {\n    const enableSelectionSave = mode.selection !== this.state.confirmedSelection;\n\n    return D.div(\n      { className: styles.dropdownFooter },\n      createElement(\n        Button,\n        {\n          className: styles.dropdownButton,\n          bsStyle: 'danger',\n          onClick: () => this.closeDropdown({ saveSelection: false }),\n        },\n        'Cancel'\n      ),\n      createElement(\n        Button,\n        {\n          className: styles.dropdownButton,\n          bsStyle: 'success',\n          disabled: !enableSelectionSave,\n          onClick: () => this.closeDropdown({ saveSelection: true }),\n        },\n        'Select'\n      )\n    );\n  }\n\n  private renderTree(mode: ExpandedMode): ReactElement<any> {\n    const inSearchMode = mode.type === 'search';\n    const renderedForest = inSearchMode ? this.state.searchResult.forest : this.state.forest;\n    const searchTerm = inSearchMode && this.state.searchText ? this.state.searchText.toLowerCase() : undefined;\n\n    const config: LazyTreeSelectorProps<Node> = {\n      forest: renderedForest,\n      isLeaf: (item) =>\n        item.children ? item.children.length === 0 && !this.state.model.hasMoreChildren(item) : undefined,\n      childrenOf: (item) => ({\n        children: item.children,\n        loading: item.loading,\n        hasMoreItems: this.state.model.hasMoreChildren(item),\n      }),\n      renderItem: (node) => this.renderItem(node, searchTerm),\n      requestMore: (node) => {\n        const path = renderedForest.getKeyPath(node);\n        this.requestChildren(path, inSearchMode);\n      },\n      selectionMode: this.props.multipleSelection ? MultipleFullSubtrees<Node>() : SingleFullSubtree<Node>(),\n      selection: mode.selection,\n      onSelectionChanged: (selection) => {\n        this.setState(\n          (state: State): State => {\n            if (state.mode.type === 'collapsed') {\n              return {};\n            }\n            return { mode: { type: state.mode.type, selection } };\n          },\n          () => {\n            if (this.props.closeDropdownOnSelection) {\n              this.closeDropdown({saveSelection: true});\n            }\n          }\n        );\n      },\n      isExpanded: (node) => node.expanded,\n      onExpandedOrCollapsed: (item, expanded) => {\n        const path = renderedForest.getKeyPath(item);\n        this.updateForest(inSearchMode, (forest) =>\n          forest.updateNode(path, (node) => TreeNode.set(node, { expanded }))\n        );\n      },\n    };\n    return createElement(LazyTreeSelector, config);\n  }\n\n  private renderItem(node: Node, highlightedTerm: string) {\n    const text = node.label ? node.label.value : node.iri.value;\n\n    let parts: ReactNode[] = [text];\n    if (highlightedTerm) {\n      const startIndex = text.toLowerCase().indexOf(highlightedTerm);\n      if (startIndex >= 0) {\n        const endIndex = startIndex + highlightedTerm.length;\n        parts = [\n          text.substring(0, startIndex),\n          D.span({ className: styles.highlighted }, text.substring(startIndex, endIndex)),\n          text.substring(endIndex),\n        ];\n      }\n    }\n\n    return D.span(\n      {\n        title: node.iri.value,\n        className: node.error ? styles.error : undefined,\n      },\n      ...parts\n    );\n  }\n\n  private requestChildren(path: KeyPath, isSearching: boolean) {\n    let changePromise: ForestChange<Node>;\n    this.updateForest(\n      isSearching,\n      (forest, state) => {\n        const [loadingForest, forestChange] = queryMoreChildren(\n          (parent) => state.model.loadMoreChildren(parent),\n          forest,\n          path\n        );\n        changePromise = forestChange;\n        return loadingForest;\n      },\n      () => {\n        const cancellation = isSearching ? this.search : this.cancellation;\n        cancellation.map(changePromise).onValue((change) => this.updateForest(isSearching, change));\n      }\n    );\n  }\n\n  private restoreTreeFromLeafNodes(searchResult: SparqlClient.Bindings): Kefir.Property<KeyedForest<Node>> {\n    const leafs = searchResult\n      .map(\n        ({ item, score = Rdf.literal('0'), label, hasChildren }): Node => {\n          if (!(item.isIri() && label.isLiteral())) {\n            return undefined;\n          }\n          const certainlyLeaf = hasChildren.isLiteral() && hasChildren.value === 'false';\n          return {\n            iri: item,\n            label: label,\n            score: parseFloat(score.isLiteral() ? score.value : ''),\n            children: [],\n            reachedLimit: certainlyLeaf,\n          };\n        }\n      )\n      .filter((node) => node !== undefined);\n\n    return this.state.model\n      .loadFromLeafs(leafs, { transitiveReduction: true })\n      .map((treeRoot) => KeyedForest.create(Node.keyOf, sealLazyExpanding(treeRoot)));\n  }\n}\n\nclass OverlayProxy extends Component<{}, {}> {\n  render() {\n    return Children.only(this.props.children);\n  }\n}\n\nexport default SemanticTreeInput;\n","/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { Set } from 'immutable';\n\nimport { KeyedForest, Traversable, NodePath } from './KeyedForest';\n\nexport type TreeSelection<T> = KeyedForest<SelectionNode<T>>;\n\ninterface SelectionBrand {\n  __selectionBrand: void;\n}\nexport type SelectionNode<T> = T & Traversable<T> & SelectionBrand;\nexport namespace SelectionNode {\n  export function set<T>(node: T, props: Partial<Traversable<T>>) {\n    return { ...(node as any), ...props } as SelectionNode<T>;\n  }\n}\n\nexport namespace TreeSelection {\n  export function empty<T extends Traversable<T>>(base: KeyedForest<T>): TreeSelection<T> {\n    const emptyRoot = ({ ...(base.root as Traversable<any>), children: [] } as any) as SelectionNode<T>;\n    return (base as TreeSelection<T>).setRoot(emptyRoot);\n  }\n\n  /**\n   * Returns true if selection node is terminal.\n   * Terminal node don't have child selection nodes and represents fully\n   * selected subtree from this node.\n   */\n  export function isTerminal<T>(node: SelectionNode<T>) {\n    return !node.children;\n  }\n\n  /**\n   * Returns true if selection node does not have any children\n   * (terminal nodes are also leafs).\n   */\n  export function isLeaf<T>(node: SelectionNode<T>) {\n    return isTerminal(node) || node.children.length === 0;\n  }\n\n  export function leafs<T>(selection: TreeSelection<T>) {\n    type MutableNodes = Map<string, Set<SelectionNode<T>>>;\n    return selection.nodes\n      .map((nodes) => nodes.find(isLeaf))\n      .filter((node) => !(node === undefined || selection.isRoot(node)))\n      .toList();\n  }\n\n  export function nodesFromKey<T>(selection: TreeSelection<T> | undefined, key: string) {\n    if (!selection) {\n      return Set<SelectionNode<T>>();\n    }\n    return selection.nodes.get(key) || Set<SelectionNode<T>>();\n  }\n\n  /**\n   * Replaces selection children with a single terminal node.\n   */\n  export function setToSingleTerminal<T extends Traversable<T>>(selection: TreeSelection<T>, node: T) {\n    return selection.updateChildren(selection.getKeyPath(selection.root), () => [\n      SelectionNode.set(node, { children: undefined }),\n    ]);\n  }\n\n  /**\n   * Creates a new tree selection by merging specified `path` (to tree node,\n   * see `KeyedTree.getNodePath(element)`) into the specified `selection`.\n   */\n  export function select<T>(selection: TreeSelection<T>, path: NodePath<T>) {\n    // common parent between old selection and newly selected path\n    let parent: SelectionNode<T> = undefined;\n    // leftover part of newly selected path\n    const addedPath = path.slice();\n\n    // searching for common part between current selection tree and newly selected path\n    while (addedPath.length > 0) {\n      const node = addedPath[0] as SelectionNode<T>;\n      const key = selection.keyOf(node);\n      const candidates = selection.nodes.get(key) || Set<SelectionNode<T>>();\n      const selectedBranch = candidates.find((candidate) => selection.getParent(candidate) === parent);\n      if (!selectedBranch) {\n        break;\n      }\n      parent = selectedBranch;\n      // leave selection untouched if we are trying to select\n      // a child of already selected leaf\n      if (TreeSelection.isTerminal(parent)) {\n        return selection;\n      }\n      addedPath.shift();\n    }\n    if (addedPath.length === 0) {\n      return selection;\n    }\n\n    // transform leftover part of path into selection forest node\n    const addedNode = addedPath.reduceRight<SelectionNode<T>>(\n      (previous, node) => SelectionNode.set(node, { children: previous ? [previous] : [] }),\n      undefined\n    );\n\n    return selection.updateChildren(selection.getKeyPath(parent), (children) =>\n      addedNode ? [...children, addedNode] : undefined\n    );\n  }\n\n  export function makeTerminal<T>(selection: TreeSelection<T>, key: string): TreeSelection<T> {\n    const removeChildren = () => undefined;\n    return (selection.nodes.get(key) || Set<SelectionNode<T>>()).reduce(\n      (acc, node) => acc.updateChildren(acc.getKeyPath(node), removeChildren),\n      selection\n    );\n  }\n\n  export function selectTerminal<T>(selection: TreeSelection<T>, path: NodePath<T>) {\n    const lastNode = path[path.length - 1] as SelectionNode<T>;\n    return makeTerminal(select(selection, path), selection.keyOf(lastNode));\n  }\n\n  /**\n   * Creates a new tree selection by removing any paths to nodes with\n   * specified `key` from the specified `selection`.\n   */\n  export function unselect<T>(selection: TreeSelection<T>, key: string) {\n    let current = selection;\n    // iterate until all items with specified key are removed\n    while (true) {\n      const nodes = current.nodes.get(key);\n      if (!nodes || nodes.size === 0) {\n        return current;\n      }\n\n      const unselectedNode = nodes.first();\n      if (current.isRoot(unselectedNode)) {\n        // make root non-terminal when trying to unselect it\n        return isTerminal(current.root) ? current.setRoot(SelectionNode.set(current.root, { children: [] })) : current;\n      }\n\n      const pathToRemove = current.getNodePath(unselectedNode).slice();\n\n      // walk up until encounter parent for multiple leafs\n      // to remove all intermediate non-shared with other leafs parents\n      let removedNode = pathToRemove.pop();\n      for (const node of pathToRemove.reverse()) {\n        if (current.isRoot(node)) {\n          break;\n        }\n        if (node.children && node.children.length > 1) {\n          break;\n        }\n        removedNode = node;\n      }\n\n      current = excludeNode(current, removedNode);\n    }\n  }\n\n  function excludeNode<T>(selection: TreeSelection<T>, node: SelectionNode<T>) {\n    const parent = selection.getParent(node);\n    return selection.updateChildren(selection.getKeyPath(parent), (children) =>\n      children.filter((child) => child !== node)\n    );\n  }\n\n  export function selectAndCollapseToTerminal<T extends Traversable<T>>(\n    selection: TreeSelection<T>,\n    forest: KeyedForest<T>,\n    subtree: T\n  ) {\n    const withSubtree = selectTerminal(selection, forest.getNodePath(subtree));\n    const parent = forest.getParent(subtree);\n    if (forest.isRoot(parent)) {\n      return withSubtree;\n    }\n\n    const allChildrenSelected = parent.children.every((node) => withSubtree.nodes.has(forest.keyOf(node)));\n    return allChildrenSelected ? selectAndCollapseToTerminal(withSubtree, forest, parent) : withSubtree;\n  }\n\n  export function materializeAndExclude<T extends Traversable<T>>(\n    selection: TreeSelection<T>,\n    forest: KeyedForest<T>,\n    defaultSelectedSubtree: T,\n    options: { leaveParentSelected?: boolean } = {}\n  ): TreeSelection<T> {\n    const parent = forest.getParent(defaultSelectedSubtree);\n    if (!parent) {\n      return selection;\n    }\n    const parentPath = forest.getKeyPath(parent);\n    const targetKey = forest.keyOf(defaultSelectedSubtree);\n    selection = materializeTerminalChildren(selection, forest, parentPath);\n    selection = selection.updateChildren(parentPath, (children) =>\n      children.filter((node) => selection.keyOf(node) !== targetKey)\n    );\n\n    const selectionNode = selection.fromKeyPath(parentPath);\n    if (selectionNode.children.length === 0 && !options.leaveParentSelected) {\n      const parent = forest.fromKeyPath(parentPath);\n      selection = materializeAndExclude(selection, forest, parent, options);\n    }\n    return selection;\n  }\n\n  function getParentPath(path: ReadonlyArray<string>): ReadonlyArray<string> {\n    if (path.length === 0) {\n      throw new Error('Cannot make parent path from root path');\n    }\n    return path.slice(0, path.length - 1);\n  }\n\n  function materializeTerminalChildren<T extends Traversable<T>>(\n    selection: TreeSelection<T>,\n    forest: KeyedForest<T>,\n    path: ReadonlyArray<string>\n  ): TreeSelection<T> {\n    if (!selection.fromKeyPath(path)) {\n      const parentPath = getParentPath(path);\n      selection = materializeTerminalChildren(selection, forest, parentPath);\n    }\n    const forestNode = forest.fromKeyPath(path);\n    const selectionNode = selection.fromKeyPath(path);\n    if (forestNode && isTerminal(selectionNode)) {\n      return selection.updateChildren(path, () =>\n        forestNode.children.map((child) => SelectionNode.set(child, { children: undefined }))\n      );\n    }\n    return selection;\n  }\n\n  export function childOfParent<T>(forest: KeyedForest<T>, child: T, parentKey: string | undefined): boolean {\n    if (!parent) {\n      return false;\n    }\n    let currentParent = forest.getParent(child);\n    while (currentParent) {\n      if (forest.keyOf(currentParent) === parentKey) {\n        return true;\n      }\n      currentParent = forest.getParent(currentParent);\n    }\n    return false;\n  }\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\n\nexport type KeyPath = ReadonlyArray<string>;\nexport type NodePath<T> = ReadonlyArray<T>;\n\nexport interface Traversable<T> {\n  readonly children?: ReadonlyArray<T>;\n}\n\ninterface ParentReference<T> {\n  readonly parent: T;\n  readonly index: number;\n}\n\n/**\n * Describes an immutable tree data structure\n * where every node has a string key.\n *\n * There could be multiple nodes with the same key but they should have\n * different identities (determined by `Immutable.is()` value equality test).\n */\nexport class KeyedForest<T extends Traversable<T>> {\n  /**\n   * Map which holds all tree nodes indexed by their keys.\n   */\n  readonly nodes: Immutable.Map<string, Immutable.Set<T>>;\n\n  private readonly parents: Immutable.Map<T, ParentReference<T>>;\n\n  private constructor(public readonly keyOf: (node: T) => string, public readonly root: T) {\n    const mutableNodes = Immutable.Map<string, Immutable.Set<T>>([[keyOf(root), Immutable.Set([root])]]).asMutable();\n    const mutableParents = Immutable.Map<T, ParentReference<T>>([[root, { parent: undefined, index: 0 }]]).asMutable();\n    computeMappingAndPaths(this.keyOf, mutableNodes, mutableParents, root);\n    this.nodes = mutableNodes.asImmutable();\n    this.parents = mutableParents.asImmutable();\n  }\n\n  static create<T extends Traversable<T>>(keyOf: (node: T) => string, root: T) {\n    return new KeyedForest(keyOf, root);\n  }\n\n  /**\n   * True if the node is a root of this tree; otherwise false.\n   */\n  isRoot(node: T): boolean {\n    return node === this.root;\n  }\n\n  /**\n   * Returns any node with the specified key.\n   */\n  getFirst(key: string): T | undefined {\n    const nodes = this.nodes.get(key);\n    return nodes ? nodes.first() : undefined;\n  }\n\n  /**\n   * Returns a parent node for the specified node in this tree,\n   * or undefined if the specified node is root.\n   */\n  getParent(node: T): T | undefined {\n    const reference = this.parents.get(node);\n    if (!reference) {\n      throw new Error('Cannot get parent for node from another forest.');\n    }\n    return reference.parent;\n  }\n\n  /**\n   * Returns a descending tree path from root to the specified node\n   * represented by subsequent node keys.\n   */\n  getKeyPath(node: T): KeyPath {\n    const path: string[] = [];\n    let current = node;\n    while (current) {\n      const reference = this.parents.get(current);\n      if (!reference) {\n        throw new Error('Cannot compute path to node from another forest.');\n      }\n      const { parent } = reference;\n      if (parent) {\n        path.unshift(this.keyOf(current));\n      }\n      current = parent;\n    }\n    return path;\n  }\n\n  fromKeyPath(path: KeyPath): T | undefined {\n    let current = this.root;\n    for (const childKey of path) {\n      const index = this.getChildIndex(current, childKey);\n      if (typeof index !== 'number') {\n        return undefined;\n      }\n      current = current.children[index];\n      if (!current) {\n        break;\n      }\n    }\n    return current;\n  }\n\n  getChildIndex(parent: T, childKey: string): number | undefined {\n    const candidates = this.nodes.get(childKey);\n    if (!candidates) {\n      return undefined;\n    }\n    let reference: ParentReference<T> | undefined;\n    candidates.find((child) => {\n      reference = this.parents.get(child);\n      return reference && reference.parent === parent;\n    });\n    return reference ? reference.index : undefined;\n  }\n\n  /**\n   * Returns a descending tree path from root to the specified node\n   * as list of nodes including the specified node.\n   */\n  getNodePath(node: T): NodePath<T> {\n    const path: T[] = [];\n    let current = node;\n    do {\n      path.unshift(current);\n      const { parent } = this.parents.get(current);\n      current = parent;\n    } while (current);\n    return path;\n  }\n\n  setRoot(root: T) {\n    return new KeyedForest(this.keyOf, root);\n  }\n\n  mapRoot(update: (root: T) => T) {\n    return this.setRoot(update(this.root));\n  }\n\n  updateNode(path: KeyPath, update: (node: T) => T) {\n    const root = this.updateNodeAt(this.root, path, 0, update);\n    return this.setRoot(root);\n  }\n\n  removeNode(path: KeyPath) {\n    if (path.length === 0) {\n      throw new Error('Cannot remove root node.');\n    }\n    const lastKeyIndex = path.length - 1;\n    const parentPath = path.slice(0, lastKeyIndex);\n    return this.updateNode(parentPath, (parent) => {\n      const index = this.getChildIndex(parent, path[lastKeyIndex]);\n      const children = [...parent.children];\n      children.splice(index, 1);\n      return { ...(parent as any), children } as T;\n    });\n  }\n\n  private updateNodeAt(node: T, path: KeyPath, pathIndex: number, update: (node: T) => T): T {\n    if (pathIndex === path.length) {\n      return update(node);\n    } else {\n      const childKey = path[pathIndex];\n      const index = this.getChildIndex(node, childKey);\n      const child = node.children[index];\n      const children = [...node.children];\n      children.splice(index, 1, this.updateNodeAt(child, path, pathIndex + 1, update));\n      return { ...(node as any), children } as T;\n    }\n  }\n\n  updateChildren(path: KeyPath, update: (children: ReadonlyArray<T>) => ReadonlyArray<T>) {\n    return this.updateNode(path, (node) => ({ ...(node as any), children: update(node.children) } as T));\n  }\n}\n\nfunction computeMappingAndPaths<T extends Traversable<T>>(\n  keyOf: (node: T) => string,\n  mutableMapping: Immutable.Map<string, Immutable.Set<T>>,\n  mutableParents: Immutable.Map<T, ParentReference<T>>,\n  parent: T\n) {\n  if (!parent.children) {\n    return;\n  }\n\n  parent.children.forEach((node, index) => {\n    mutableParents.update(node, (existing) => {\n      if (existing) {\n        throw new Error(\n          `Duplicate item '${keyOf(node)}' exists in both ` +\n            `'${keyOf(existing.parent)}' and '${keyOf(parent)}' parents`\n        );\n      }\n      return { parent, index };\n    });\n    mutableMapping.update(keyOf(node), Immutable.Set<T>(), (items) => items.add(node));\n\n    computeMappingAndPaths(keyOf, mutableMapping, mutableParents, node);\n  });\n}\n\nexport function mapBottomUp<T extends Traversable<T>>(root: T, mapper: (node: T) => T): T {\n  const mapNode = (node: T) => {\n    if (node.children) {\n      const children = node.children.map(mapNode);\n      return mapper({ ...(node as any), children });\n    } else {\n      return mapper(node);\n    }\n  };\n  return mapNode(root);\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { KeyedForest, Traversable } from './KeyedForest';\nimport { TreeSelection, SelectionNode } from './TreeSelection';\n\nexport interface SelectionMode<T> {\n  readonly renderSelected: RenderSelected<T>;\n  readonly change: ChangeSelection<T>;\n}\n\nexport enum CheckState {\n  None = 0,\n  Partial,\n  Full,\n  FullGreyedOut,\n}\n\nexport type RenderSelected<T> = (\n  forest: KeyedForest<T>,\n  item: T,\n  selection: TreeSelection<T> | undefined,\n  itemSelection: SelectionNode<T> | undefined,\n  defaultSelection: SelectionNode<T> | undefined\n) => CheckState;\n\nexport type ChangeSelection<T> = (\n  forest: KeyedForest<T>,\n  item: T,\n  previous: TreeSelection<T>,\n  itemSelection: SelectionNode<T> | undefined,\n  defaultSelection: SelectionNode<T> | undefined\n) => TreeSelection<T> | undefined;\n\ninterface Node extends Traversable<Node> {\n  __nodeBrand: void;\n}\n\nconst singleFullSubtree: SelectionMode<Node> = {\n  renderSelected: (forest, item, selection, itemSelection, defaultSelection) => {\n    if (defaultSelection) {\n      return CheckState.Full;\n    } else if (itemSelection) {\n      return TreeSelection.isLeaf(itemSelection) ? CheckState.Full : CheckState.Partial;\n    } else {\n      return CheckState.None;\n    }\n  },\n  change: (forest, item, previous, itemSelection, defaultSelection) => {\n    const empty = TreeSelection.empty(forest);\n    if (itemSelection) {\n      return empty;\n    }\n    // When a user selects a node then we include it into tree selection.\n    // At this point we don't know about all other nodes with the same key\n    // in other parts of tree because they aren't loaded yet.\n    // It's possible to include at least all currently loaded nodes into\n    // the new selection but this wasn't implemented.\n    return TreeSelection.selectTerminal(empty, forest.getNodePath(item));\n  },\n};\n/**\n * Allows to select only single subtree. When a node is selected,\n * resets selection to subtree of the node.\n * Can be used with depth- and breadth-lazy loading.\n */\nexport function SingleFullSubtree<T>(): SelectionMode<T> {\n  return singleFullSubtree as SelectionMode<any>;\n}\n\nconst multipleFullSubtrees: SelectionMode<Node> = {\n  renderSelected: (forest, item, selection, itemSelection, defaultSelection) => {\n    if (defaultSelection) {\n      return CheckState.FullGreyedOut;\n    }\n    return singleFullSubtree.renderSelected(forest, item, selection, itemSelection, defaultSelection);\n  },\n  change: (forest, item, previous, itemSelection, defaultSelection) => {\n    if (defaultSelection) {\n      return undefined;\n    }\n    if (itemSelection) {\n      return TreeSelection.unselect(previous, forest.keyOf(item));\n    } else {\n      return TreeSelection.selectTerminal(previous, forest.getNodePath(item));\n    }\n  },\n};\n/**\n * Allows to select multiple whole subtrees (without the ability to\n * unselect selected node's children).\n * Can be used with depth- and breadth-lazy loading.\n */\nexport function MultipleFullSubtrees<T>(): SelectionMode<T> {\n  return multipleFullSubtrees as SelectionMode<any>;\n}\n\nconst multiplePartialSubtrees: SelectionMode<Node> = {\n  renderSelected: singleFullSubtree.renderSelected,\n  change: (forest, item, previous, itemSelection, defaultSelection) => {\n    if (defaultSelection) {\n      return TreeSelection.materializeAndExclude(previous, forest, item);\n    }\n    const itemKey = forest.keyOf(item);\n    if (itemSelection) {\n      return TreeSelection.unselect(previous, itemKey);\n    } else {\n      return TreeSelection.selectAndCollapseToTerminal(previous, forest, item);\n    }\n  },\n};\n/**\n * Allows to select single subtree and partially unselect its children.\n * Can be used only with depth-lazy loading.\n */\nexport function MultiplePartialSubtrees<T>(): SelectionMode<T> {\n  return multiplePartialSubtrees as SelectionMode<any>;\n}\n\ninterface SubtreeNode extends Node {\n  isSubtreeRoot?: boolean;\n}\n\nexport interface PartialSubtreesMode<T> extends SelectionMode<T> {\n  isSelectedSubtree(itemSelection: SelectionNode<T>): boolean;\n  getSelectedSubtrees(selection: TreeSelection<T>): Array<SelectionNode<T>>;\n}\n\nconst partialSubtrees: PartialSubtreesMode<SubtreeNode> = {\n  isSelectedSubtree: (itemSelection) => {\n    return Boolean(itemSelection.isSubtreeRoot);\n  },\n  getSelectedSubtrees: (selection) => {\n    const roots: Array<SelectionNode<SubtreeNode>> = [];\n    selection.nodes.forEach((nodes) => {\n      nodes.forEach((node) => {\n        if (node.isSubtreeRoot) {\n          roots.push(node);\n        }\n      });\n    });\n    return roots;\n  },\n  renderSelected: (forest, item, selection, itemSelection, defaultSelection) => {\n    const state = singleFullSubtree.renderSelected(forest, item, selection, itemSelection, defaultSelection);\n    const subtreeRoot = findSubtreeParent(selection, itemSelection);\n    // hide partial selection of subtree parents\n    return subtreeRoot || defaultSelection ? state : CheckState.None;\n  },\n  change: (forest, item, previous, itemSelection, defaultSelection) => {\n    if (itemSelection && itemSelection.isSubtreeRoot) {\n      const itemKey = forest.keyOf(item);\n      return TreeSelection.unselect(previous, itemKey);\n    }\n\n    const itemPath = forest.getKeyPath(item);\n    const parentSubtree = findSubtreeInPath(previous, itemPath);\n\n    if (parentSubtree) {\n      if (itemSelection || defaultSelection) {\n        return TreeSelection.materializeAndExclude(previous, forest, item, { leaveParentSelected: true });\n      } else {\n        return TreeSelection.selectAndCollapseToTerminal(previous, forest, item);\n      }\n    } else {\n      const selection = TreeSelection.selectTerminal(previous, forest.getNodePath(item));\n      return selection.updateNode(itemPath, (node) => ({ ...node, isSubtreeRoot: true }));\n    }\n  },\n};\n\nfunction findSubtreeParent(\n  selection: TreeSelection<SubtreeNode>,\n  node: SelectionNode<SubtreeNode> | undefined\n): SelectionNode<SubtreeNode> | undefined {\n  let current = node;\n  while (current) {\n    if (current.isSubtreeRoot) {\n      return current;\n    }\n    current = selection.getParent(current);\n  }\n  return undefined;\n}\n\nfunction findSubtreeInPath(\n  selection: TreeSelection<SubtreeNode>,\n  keyPath: ReadonlyArray<string>\n): SelectionNode<SubtreeNode> | undefined {\n  let node = selection.root;\n  for (const childKey of keyPath) {\n    if (node.isSubtreeRoot) {\n      return node;\n    }\n    const index = selection.getChildIndex(node, childKey);\n    if (typeof index !== 'number') {\n      return undefined;\n    }\n    node = node.children[index] as SelectionNode<SubtreeNode>;\n  }\n  return undefined;\n}\n\n/**\n * Allows to select multiple subtrees and partially unselect their children.\n * Parent node is automatically unselected when all every children become\n * unselected and vice versa.\n * Can be used only with depth-lazy loading.\n */\nexport function PartialSubtrees<T>(): PartialSubtreesMode<T> {\n  return partialSubtrees as PartialSubtreesMode<any>;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\n\nimport { KeyedForest, KeyPath, Traversable } from './KeyedForest';\n\nexport interface TreeNode {\n  readonly children?: ReadonlyArray<TreeNode>;\n  readonly expanded?: boolean;\n  readonly loading?: boolean;\n  readonly error?: boolean;\n}\nexport namespace TreeNode {\n  export type Properties<T> = {\n    children?: ReadonlyArray<T>;\n    expanded?: boolean;\n    loading?: boolean;\n    error?: boolean;\n  };\n\n  export function set<T extends TreeNode>(node: T, props: Properties<T>): T {\n    return { ...(node as any), ...props } as T;\n  }\n}\n\nexport type ChildrenLoader<T> = (parent: T) => Kefir.Property<T>;\nexport type ForestChange<T> = Kefir.Property<(forest: KeyedForest<T>) => KeyedForest<T>>;\n\nexport function queryMoreChildren<T extends TreeNode & Traversable<T>>(\n  loadChildren: ChildrenLoader<T>,\n  forest: KeyedForest<T>,\n  path: KeyPath\n): [KeyedForest<T>, ForestChange<T>] {\n  const node = forest.fromKeyPath(path);\n  if (node.loading || node.error) {\n    return [forest, Kefir.constant((r) => r)];\n  }\n\n  const newForest = forest.updateNode(path, (target) => TreeNode.set(target, { loading: true }));\n\n  const change = loadChildren(node).map((loaded) => {\n    return (currentForest: KeyedForest<T>) =>\n      currentForest.updateNode(path, () => {\n        if (loaded.error) {\n          console.error(loaded.error);\n        }\n        return TreeNode.set(loaded, { loading: false });\n      });\n  });\n\n  return [newForest, change];\n}\n\nexport function mergeRemovingDuplicates<T>(\n  keyOf: (item: T) => string,\n  oldNodes: ReadonlyArray<T>,\n  newNodes: ReadonlyArray<T>\n): T[] {\n  const existingKeys: { [key: string]: T } = Object.create(null);\n  oldNodes.forEach((node) => {\n    existingKeys[keyOf(node)] = node;\n  });\n  const nodes = [...oldNodes];\n  // don't trust data source to return elements with distinct IRIs\n  for (const node of newNodes) {\n    const key = keyOf(node);\n    if (!existingKeys[key]) {\n      existingKeys[key] = node;\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\nexport function loadPath<T extends TreeNode & Traversable<T>>(\n  shouldLoadChildren: (parent: T) => boolean,\n  loadChildren: ChildrenLoader<T>,\n  forest: KeyedForest<T>,\n  path: KeyPath\n): Kefir.Property<KeyedForest<T>> {\n  let pathIndex = 0;\n  let latest = forest;\n  const loadedPath = [...latest.getKeyPath(latest.root)];\n\n  return Kefir.repeat<boolean>(() => {\n    if (pathIndex >= path.length) {\n      return false;\n    }\n    const targetKey = path[pathIndex];\n    const parent = latest.fromKeyPath(loadedPath);\n\n    if (shouldLoadChildren(parent)) {\n      const parentPath = latest.getKeyPath(parent);\n      const [loading, forestChange] = queryMoreChildren(loadChildren, latest, parentPath);\n      return forestChange.map((change) => {\n        latest = change(latest);\n        return true;\n      });\n    }\n\n    const children: ReadonlyArray<T> = parent.children;\n    if (children) {\n      const target = children.find((child) => latest.keyOf(child) === targetKey);\n      if (target) {\n        pathIndex++;\n        loadedPath.push(targetKey);\n        return Kefir.constant(true);\n      }\n    }\n\n    return Kefir.constantError<any>(new Error(`Failed to find child ${targetKey} on parent ${latest.keyOf(parent)}`));\n  })\n    .takeErrors(1)\n    .last()\n    .map(() => latest)\n    .toProperty();\n}\n\nexport function expandPath<T extends TreeNode & Traversable<T>>(forest: KeyedForest<T>, path: KeyPath) {\n  const expandNode = (node: T, nextPathIndex: number): T => {\n    if (nextPathIndex >= path.length) {\n      // leave target node collapsed\n      return node;\n    }\n    const key = path[nextPathIndex];\n    const index = forest.getChildIndex(node, key);\n    const child = node.children[index];\n    const children = [...node.children];\n    children.splice(index, 1, expandNode(child, nextPathIndex + 1));\n    return TreeNode.set(node, { children, expanded: true });\n  };\n  return forest.setRoot(expandNode(forest.root, 0));\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\nimport { orderBy } from 'lodash';\nimport * as SparqlJs from 'sparqljs';\n\nimport { Rdf } from 'platform/api/rdf';\nimport { SparqlClient } from 'platform/api/sparql';\n\nimport { breakGraphCycles, transitiveReduction, findRoots } from './GraphAlgorithms';\nimport { KeyedForest, KeyPath, mapBottomUp } from './KeyedForest';\nimport { TreeNode, mergeRemovingDuplicates } from './NodeModel';\n\nexport interface Node extends TreeNode {\n  readonly iri: Rdf.Iri;\n  readonly label?: Rdf.Literal;\n  readonly children?: ReadonlyArray<Node>;\n  readonly reachedLimit?: boolean;\n  /** search relevance */\n  readonly score?: number;\n}\nexport namespace Node {\n  export const rootKey = 'SparqlNode:root';\n  export const keyOf = (node: Node) => (node.iri ? node.iri.value : rootKey);\n  export const readyToLoadRoot: Node = {\n    iri: Rdf.iri(rootKey),\n    children: undefined,\n    reachedLimit: false,\n  };\n  export const emptyRoot: Node = {\n    iri: Rdf.iri(rootKey),\n    children: [],\n    reachedLimit: true,\n  };\n\n  export const readyToLoadForest = KeyedForest.create(keyOf, readyToLoadRoot);\n  export const emptyForest = KeyedForest.create(keyOf, emptyRoot);\n\n  export function set(node: Node, props: Partial<Node>): Node {\n    return { ...node, ...props };\n  }\n\n  export function getLabel(node: Node) {\n    return node.label ? node.label.value : node.iri.value;\n  }\n}\n\nexport class SparqlNodeModel {\n  private readonly rootsQuery: SparqlJs.SelectQuery;\n  private readonly childrenQuery: SparqlJs.SelectQuery;\n  private readonly parentsQuery: SparqlJs.SelectQuery;\n  private readonly limit: number | undefined;\n\n  readonly sparqlOptions: () => SparqlClient.SparqlOptions;\n\n  constructor(params: {\n    rootsQuery: SparqlJs.SelectQuery;\n    childrenQuery: SparqlJs.SelectQuery;\n    parentsQuery: SparqlJs.SelectQuery;\n    limit?: number;\n    sparqlOptions: () => SparqlClient.SparqlOptions;\n  }) {\n    const { rootsQuery, childrenQuery, parentsQuery, limit, sparqlOptions } = params;\n    this.rootsQuery = rootsQuery;\n    this.childrenQuery = childrenQuery;\n    this.parentsQuery = parentsQuery;\n    this.limit = limit;\n    this.sparqlOptions = sparqlOptions;\n  }\n\n  hasMoreChildren(node: Node): boolean {\n    return !node.error && !node.reachedLimit;\n  }\n\n  loadMoreChildren(parent: Node): Kefir.Property<Node> {\n    const parametrized =\n      Node.keyOf(parent) === Node.rootKey\n        ? this.rootsQuery\n        : SparqlClient.setBindings(this.childrenQuery, { parent: parent.iri });\n\n    const hasLimit = typeof this.limit === 'number';\n    if (hasLimit) {\n      parametrized.limit = this.limit;\n      parametrized.offset = parent.children ? parent.children.length : 0;\n    }\n\n    type Result = { nodes?: Node[]; error?: any };\n    return SparqlClient.select(parametrized, this.sparqlOptions())\n      .map<Result>((queryResult) => ({ nodes: nodesFromQueryResult(queryResult) }))\n      .flatMapErrors<Result>((error) => Kefir.constant({ error }))\n      .map(\n        ({ nodes, error }): Node => {\n          if (error) {\n            return Node.set(parent, { error });\n          } else {\n            const initialChildren = parent.children ? parent.children : [];\n            const children = mergeRemovingDuplicates(Node.keyOf, initialChildren, nodes);\n            return Node.set(parent, {\n              error: undefined,\n              children,\n              reachedLimit: !hasLimit || children.length === initialChildren.length || nodes.length < this.limit,\n            });\n          }\n        }\n      )\n      .toProperty();\n  }\n\n  loadFromLeafs(leafs: ReadonlyArray<Node>, options: { transitiveReduction: boolean }): Kefir.Property<Node> {\n    const initialOrphans = Immutable.List(leafs as Node[])\n      .groupBy((node) => node.iri.value)\n      .map((group) => group.first())\n      .map<MutableNode>(({ iri, label, score, reachedLimit }) => ({\n        iri,\n        label,\n        score,\n        reachedLimit,\n        children: new Set<MutableNode>(),\n      }))\n      .toArray();\n\n    if (initialOrphans.length === 0) {\n      return Kefir.constant(Node.readyToLoadRoot);\n    }\n\n    return restoreGraphFromLeafs(initialOrphans, this.parentsQuery, this.sparqlOptions()).map((nodes) => {\n      const graph = Array.from(nodes.values());\n      breakGraphCycles(graph);\n      if (options.transitiveReduction) {\n        transitiveReduction(graph);\n      }\n      const roots = findRoots(graph);\n      const children = asImmutableForest(roots);\n      return Node.set(Node.readyToLoadRoot, { children });\n    });\n  }\n\n  /** @returns parent key for the specified child key. */\n  loadParent(key: string): Kefir.Property<string> {\n    const parameters = [{ item: Rdf.iri(key) }];\n    const parametrized = SparqlClient.prepareParsedQuery(parameters)(this.parentsQuery);\n    return SparqlClient.select(parametrized, this.sparqlOptions())\n      .flatMap(\n        ({ results }): Kefir.Observable<string> => {\n          for (const { item, parent } of results.bindings) {\n            if (!(item && item.value === key)) {\n              continue;\n            }\n            if (!(parent && parent.isIri())) {\n              return Kefir.constantError<any>(\n                new Error(`parentsQuery returned tuple without 'parent' (or it isn't an IRI)`)\n              );\n            }\n            return Kefir.constant(parent.value);\n          }\n          return Kefir.constant(Node.rootKey);\n        }\n      )\n      .toProperty();\n  }\n}\n\nexport function nodesFromQueryResult(result: SparqlClient.SparqlSelectResult): Node[] {\n  return result.results.bindings\n    .map(\n      (binding): Node => {\n        const { item, label, hasChildren } = binding;\n        if (!(item && item.isIri())) {\n          return undefined;\n        }\n\n        const nodeLabel = label && label.isLiteral() ? label : undefined;\n\n        return hasChildren && hasChildren.value === 'false'\n          ? { iri: item, label: nodeLabel, children: [], reachedLimit: true }\n          : { iri: item, label: nodeLabel, reachedLimit: false };\n      }\n    )\n    .filter((node) => node !== undefined);\n}\n\n/**\n * Marks every node with at least one child as finished loading.\n */\nexport function sealLazyExpanding(root: Node): Node {\n  return mapBottomUp<Node>(root, (node) => {\n    const sealed =\n      !node.reachedLimit && node.children && node.children.length > 0 ? Node.set(node, { reachedLimit: true }) : node;\n    const expanded = sealed.reachedLimit && !sealed.expanded ? Node.set(sealed, { expanded: true }) : sealed;\n    return expanded;\n  });\n}\n\nexport interface MutableNode {\n  iri: Rdf.Iri;\n  label: Rdf.Literal;\n  reachedLimit: boolean;\n  children: Set<MutableNode>;\n  score?: number;\n}\n\nfunction restoreGraphFromLeafs(\n  leafs: MutableNode[],\n  parentsQuery: SparqlJs.SelectQuery,\n  options: SparqlClient.SparqlOptions\n): Kefir.Property<Map<string, MutableNode>> {\n  return Kefir.stream<Map<string, MutableNode>>((emitter) => {\n    const nodes = new Map(\n      leafs.map<[string, MutableNode]>((node) => [node.iri.value, node])\n    );\n    let unresolvedOrphans = new Set(nodes.keys());\n    let disposed = false;\n\n    const onError = (error: any) => {\n      disposed = true;\n      emitter.error(error);\n      emitter.end();\n    };\n\n    type ParentsResult = { requested: string[]; result: SparqlClient.SparqlSelectResult };\n    let onResult: (result: ParentsResult) => void;\n\n    const request = (orphanKeys: string[]) => {\n      const parametrized = SparqlClient.prepareParsedQuery(orphanKeys.map((key) => ({ item: Rdf.iri(key) })))(\n        parentsQuery\n      );\n      SparqlClient.select(parametrized, options)\n        .map((result) => ({ result, requested: orphanKeys }))\n        .onValue(onResult)\n        .onError(onError);\n    };\n\n    onResult = ({ result, requested }) => {\n      if (disposed) {\n        return;\n      }\n\n      for (const { item, parent, parentLabel } of result.results.bindings) {\n        if (!(item && item.isIri() && parent && parent.isIri())) {\n          continue;\n        }\n\n        unresolvedOrphans.delete(item.value);\n        const node = nodes.get(item.value);\n\n        const existingNode = nodes.get(parent.value);\n        if (existingNode) {\n          existingNode.children.add(node);\n        } else {\n          const parentOrphan: MutableNode = {\n            iri: parent,\n            label: parentLabel && parentLabel.isLiteral() ? parentLabel : undefined,\n            reachedLimit: false,\n            children: new Set<MutableNode>([nodes.get(item.value)]),\n          };\n          nodes.set(parentOrphan.iri.value, parentOrphan);\n          unresolvedOrphans = unresolvedOrphans.add(parentOrphan.iri.value);\n        }\n      }\n\n      for (const requestedKey of requested) {\n        unresolvedOrphans.delete(requestedKey);\n      }\n\n      if (unresolvedOrphans.size === 0) {\n        emitter.emit(nodes);\n        emitter.end();\n      } else {\n        request(Array.from(unresolvedOrphans.values()));\n      }\n    };\n\n    request(leafs.map((orphan) => orphan.iri.value));\n\n    return () => {\n      disposed = true;\n    };\n  }).toProperty();\n}\n\nconst COMPARE_BY_SCORE_THEN_BY_LABEL: ReadonlyArray<(node: Node) => any> = [\n  (node: Node) => (typeof node.score === 'number' ? -node.score : 0),\n  (node: Node) => (node.label ? node.label.value : node.iri.value),\n];\n\n/** Convert into immutable tree and sort by search relevance. */\nfunction asImmutableForest(roots: Set<MutableNode>): ReadonlyArray<Node> {\n  return Array.from(roots).map(\n    (root): Node => {\n      const children = orderBy(asImmutableForest(root.children), COMPARE_BY_SCORE_THEN_BY_LABEL);\n      const total = children.reduce((sum, { score = 0 }) => sum + score, 0);\n      return {\n        iri: root.iri,\n        label: root.label,\n        children,\n        reachedLimit: root.reachedLimit,\n        score: total + (root.score === undefined ? 0 : root.score),\n      };\n    }\n  );\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * Break cycles in directed graph using topological sort.\n */\nexport function breakGraphCycles<T extends { children: Set<T> }>(graph: T[]) {\n  const visiting = new Set<T>();\n  const visited = new Set<T>();\n  const edgesToRemove: Array<[T, T]> = [];\n\n  const toVisit = graph.slice();\n  while (toVisit.length > 0) {\n    const node = toVisit.pop();\n    if (visited.has(node)) {\n      continue;\n    }\n\n    if (visiting.has(node)) {\n      visiting.delete(node);\n      visited.add(node);\n    } else {\n      visiting.add(node);\n      toVisit.push(node);\n\n      node.children.forEach((child) => {\n        if (visiting.has(child)) {\n          edgesToRemove.push([node, child]);\n        } else if (!visited.has(child)) {\n          toVisit.push(child);\n        }\n      });\n    }\n  }\n\n  for (const [parent, child] of edgesToRemove) {\n    parent.children.delete(child);\n  }\n}\n\n/**\n * Remove redundant edges from directed acyclic graph\n * (so reachablility would be the same), should be O(N(N + E)).\n */\nexport function transitiveReduction<T extends { children: Set<T> }>(graph: T[]) {\n  const edgesToRemove: Array<[T, T]> = [];\n  const visited = new Set<T>();\n\n  function searchForRedundantEdges(parent: T, currentChild: T) {\n    visited.add(currentChild);\n    currentChild.children.forEach((grandChild) => {\n      if (visited.has(grandChild)) {\n        return;\n      }\n      if (parent.children.has(grandChild)) {\n        edgesToRemove.push([parent, grandChild]);\n      }\n      searchForRedundantEdges(parent, grandChild);\n    });\n  }\n\n  for (const node of graph) {\n    node.children.forEach((child) => {\n      visited.clear();\n      searchForRedundantEdges(node, child);\n    });\n  }\n\n  for (const [parent, child] of edgesToRemove) {\n    parent.children.delete(child);\n  }\n}\n\nexport function findRoots<T extends { children: Set<T> }>(graph: T[]): Set<T> {\n  const roots = new Set(graph);\n  graph.forEach((node) => {\n    node.children.forEach((child) => roots.delete(child));\n  });\n  return roots;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport * as React from 'react';\nimport { Component, ComponentClass, CSSProperties, ReactElement, SyntheticEvent } from 'react';\nimport * as Immutable from 'immutable';\nimport * as classnames from 'classnames';\nimport { AutoSizer, ColumnSizer, ColumnSizerProps, List, ListProps, ListRowProps } from 'react-virtualized';\n\nimport { Spinner } from '../../ui/spinner/Spinner';\n\nimport { KeyedForest, Traversable, KeyPath } from './KeyedForest';\nimport { TreeSelection, SelectionNode } from './TreeSelection';\nimport { SelectionMode, CheckState } from './SelectionMode';\n\nimport * as styles from './LazyTreeSelector.scss';\n\nexport interface LazyTreeSelectorProps<T extends Traversable<T> = Traversable<any>> {\n  className?: string;\n  style?: CSSProperties;\n\n  forest: KeyedForest<T>;\n  isLeaf: (item: T) => boolean | undefined;\n  childrenOf: (\n    item: T\n  ) => {\n    loading?: boolean;\n    hasMoreItems?: boolean;\n  };\n  requestMore: (item: T) => void;\n  renderItem: (item: T) => React.ReactElement<any>;\n  renderEmpty?: () => React.ReactElement<any>;\n  itemHeight?: number;\n\n  hideCheckboxes?: boolean;\n  selectionMode: SelectionMode<T>;\n  selection?: TreeSelection<T>;\n  onSelectionChanged?: (selectedItems: TreeSelection<T>) => void;\n\n  expandedByDefault?: boolean;\n  isExpanded: (item: T) => boolean | undefined;\n  onExpandedOrCollapsed: (item: T, expanded: boolean) => void;\n  onItemClick?: (item: T) => void;\n}\n\ntype TreeNode = Traversable<any>;\n\ninterface State {\n  readonly entries?: ReadonlyArray<NodeEntry>;\n  readonly indices?: Immutable.Map<TreeNode, number>;\n}\n\nenum EntryType {\n  Node = 1,\n  Spinner,\n  Anchor,\n}\n\ntype NodeEntry = ItemEntry | SpinnerEntry | AnchorEntry;\n\ninterface ItemEntry {\n  type: EntryType.Node;\n  depth: number;\n  item: TreeNode;\n  itemSelection: SelectionNode<TreeNode> | undefined;\n  defaultSelection: SelectionNode<TreeNode> | undefined;\n  expanded: boolean;\n}\ninterface SpinnerEntry {\n  type: EntryType.Spinner;\n  depth: number;\n}\ninterface AnchorEntry {\n  type: EntryType.Anchor;\n  depth: number;\n  item: TreeNode;\n}\n\nconst OVERSCAN_ITEM_COUNT = 10;\n/**\n * Minimal required distance from rendered overscan items and an anchor to\n * request additional items at the anchor location.\n */\nconst OVERSCAN_LOAD_ANCHOR = 20;\nconst MIN_ITEM_HEIGHT = 30;\nconst PADDING_PER_DEPTH_LEVEL = 20;\n\n// workaround for older React typings\nconst VirtualizedList = (List as any) as ComponentClass<ListProps>;\n\nexport class LazyTreeSelector extends Component<LazyTreeSelectorProps, State> {\n  static readonly defaultProps: Partial<LazyTreeSelectorProps> = {\n    itemHeight: MIN_ITEM_HEIGHT,\n  };\n\n  private list: List;\n  private overscanStartIndex: number | undefined;\n  private overscanStopIndex: number | undefined;\n\n  constructor(props: LazyTreeSelectorProps, context: any) {\n    super(props, context);\n    const { entries, indices } = computeEntries(this.props);\n    this.state = { entries, indices };\n  }\n\n  componentWillReceiveProps(nextProps: LazyTreeSelectorProps) {\n    const { entries, indices } = computeEntries(nextProps);\n    this.setState({ entries, indices }, () => {\n      this.list.forceUpdateGrid();\n      this.requestItemsWithVisibleAnchors();\n    });\n  }\n\n  scrollToPath(path: KeyPath) {\n    const item = this.props.forest.fromKeyPath(path);\n    if (item && this.list) {\n      const rowIndex = this.state.indices.get(item);\n      if (typeof rowIndex === 'number') {\n        this.list.scrollToRow(rowIndex);\n      }\n    }\n  }\n\n  render() {\n    const { className, style, itemHeight, renderEmpty } = this.props;\n    const { entries } = this.state;\n\n    return (\n      <div className={classnames(styles.component, className)} style={style}>\n        <AutoSizer>\n          {({ width, height }) => (\n            <VirtualizedList\n              ref={(list) => (this.list = list as any)}\n              className={styles.virtualizedList}\n              width={width}\n              height={height}\n              rowCount={entries.length}\n              overscanRowCount={OVERSCAN_ITEM_COUNT}\n              rowHeight={Math.max(itemHeight, MIN_ITEM_HEIGHT)}\n              noRowsRenderer={renderEmpty}\n              rowRenderer={this.renderRow}\n              onRowsRendered={this.onRowsRendered}\n              // support horizontal scrolling in outer List component by setting overflow\n              // style for it and removing width restrictions from inner container\n              style={{ overflowX: 'auto', overflowY: 'scroll' }}\n              containerStyle={{\n                width: undefined,\n                maxWidth: undefined,\n                minHeight: height,\n                overflowX: 'unset',\n                overflowY: 'unset',\n              }}\n            />\n          )}\n        </AutoSizer>\n      </div>\n    );\n  }\n\n  private renderRow = (rowProps: ListRowProps) => {\n    const { index, isScrolling, key, style } = rowProps;\n    const entry = this.state.entries[index];\n    const renderedEntry = this.renderEntry(entry, index);\n    const rowStyle: CSSProperties = {\n      ...style,\n      paddingLeft: entry.depth * PADDING_PER_DEPTH_LEVEL,\n    };\n    return (\n      <div key={key} style={rowStyle}>\n        {renderedEntry}\n      </div>\n    );\n  };\n\n  private renderEntry(entry: NodeEntry, index: number): ReactElement<any> {\n    switch (entry.type) {\n      case EntryType.Node:\n        return this.renderItem(entry);\n      case EntryType.Spinner:\n      case EntryType.Anchor:\n        return <Spinner spinnerDelay={0} className={styles.spinner} />;\n    }\n  }\n\n  private onRowsRendered = (info: {\n    startIndex: number;\n    stopIndex: number;\n    overscanStartIndex: number;\n    overscanStopIndex: number;\n  }) => {\n    this.overscanStartIndex = info.overscanStartIndex;\n    this.overscanStopIndex = info.overscanStopIndex;\n    this.requestItemsWithVisibleAnchors();\n  };\n\n  private requestItemsWithVisibleAnchors() {\n    const hasRenderedRows = typeof this.overscanStartIndex === 'number' && typeof this.overscanStopIndex === 'number';\n    if (!hasRenderedRows) {\n      return;\n    }\n    const { entries } = this.state;\n    const start = Math.max(0, this.overscanStartIndex - OVERSCAN_ITEM_COUNT);\n    const end = Math.min(entries.length, this.overscanStopIndex + OVERSCAN_ITEM_COUNT);\n    for (let i = start; i < end; i++) {\n      const entry = entries[i];\n      if (entry.type === EntryType.Anchor) {\n        this.props.requestMore(entry.item);\n      }\n    }\n  }\n\n  private renderItem(entry: ItemEntry): ReactElement<any> {\n    const { item, itemSelection, defaultSelection, expanded } = entry;\n\n    const isLeaf = this.props.isLeaf(item) === true;\n    const checkState = this.props.selectionMode.renderSelected(\n      this.props.forest,\n      item,\n      this.props.selection,\n      itemSelection,\n      defaultSelection\n    );\n\n    return (\n      <div\n        className={classnames({\n          [styles.item]: true,\n          [styles.itemExpanded]: expanded,\n          [styles.itemCollapsed]: !expanded,\n        })}\n      >\n        <span\n          className={styles.expandToggle}\n          style={{ visibility: isLeaf ? 'collapse' : undefined }}\n          onClick={\n            () => {\n              this.toggleExpanded(item, expanded);\n              if (this.props.onItemClick) {\n                this.props.onItemClick(item);\n              }\n            }\n          }\n        ></span>\n        {this.props.hideCheckboxes ? null : (\n          <input\n            type=\"checkbox\"\n            checked={checkState !== CheckState.None}\n            disabled={checkState === CheckState.FullGreyedOut}\n            onChange={(e) => this.onItemCheckedChange(item, itemSelection, defaultSelection, e)}\n            ref={(input) => {\n              if (input) {\n                input.indeterminate = checkState === CheckState.Partial;\n              }\n            }}\n          />\n        )}\n        <div className={styles.itemContent} onClick={() => this.toggleExpanded(item, expanded)}>\n          {this.props.renderItem(item)}\n        </div>\n      </div>\n    );\n  }\n\n  private toggleExpanded(item: TreeNode, previouslyExpanded: boolean) {\n    const { onExpandedOrCollapsed, childrenOf, requestMore } = this.props;\n    onExpandedOrCollapsed(item, !previouslyExpanded);\n    // request children when expand an item\n    if (!previouslyExpanded) {\n      const { loading, hasMoreItems } = childrenOf(item);\n      if (!loading && hasMoreItems) {\n        requestMore(item);\n      }\n    }\n  }\n\n  private onItemCheckedChange(\n    item: TreeNode,\n    itemSelection: SelectionNode<TreeNode> | undefined,\n    defaultSelection: SelectionNode<TreeNode> | undefined,\n    event: SyntheticEvent<HTMLInputElement>\n  ) {\n    if (!this.props.onSelectionChanged) {\n      return;\n    }\n\n    const { forest, selectionMode } = this.props;\n    const previous = this.props.selection || TreeSelection.empty(forest);\n    const next = selectionMode.change(forest, item, previous, itemSelection, defaultSelection);\n    if (!next) {\n      return;\n    }\n\n    this.props.onSelectionChanged(next);\n  }\n}\n\nfunction computeEntries(\n  props: LazyTreeSelectorProps\n): {\n  entries: NodeEntry[];\n  indices: Immutable.Map<TreeNode, number>;\n} {\n  const entries: NodeEntry[] = [];\n  describeChildren(props, props.forest.root, props.selection ? props.selection.root : undefined, undefined, 0, entries);\n\n  const indices = Immutable.Map<TreeNode, number>().withMutations((mapping) => {\n    entries.forEach((entry, index) => {\n      if (entry.type === EntryType.Node) {\n        mapping.set(entry.item, index);\n      }\n    });\n  });\n\n  return { entries, indices };\n}\n\nfunction describeChildren(\n  props: LazyTreeSelectorProps,\n  item: TreeNode,\n  parentSelection: SelectionNode<TreeNode> | undefined,\n  defaultSelection: SelectionNode<TreeNode> | undefined,\n  depth: number,\n  output: NodeEntry[]\n): void {\n  if (item.children) {\n    const { forest, selection } = props;\n    for (const child of item.children as ReadonlyArray<TreeNode>) {\n      let itemSelection: SelectionNode<TreeNode> | undefined;\n      if (parentSelection) {\n        const key = forest.keyOf(child);\n        const childIndex = selection.getChildIndex(parentSelection, key);\n        itemSelection = typeof childIndex === 'number' ? parentSelection.children[childIndex] : undefined;\n      }\n      describeItem(props, child, itemSelection, defaultSelection, depth, output);\n    }\n  }\n\n  const { loading, hasMoreItems } = props.childrenOf(item);\n  if (loading) {\n    output.push({ type: EntryType.Spinner, depth });\n  } else if (hasMoreItems) {\n    output.push({ type: EntryType.Anchor, depth, item });\n  }\n}\n\nfunction describeItem(\n  props: LazyTreeSelectorProps,\n  item: TreeNode,\n  itemSelection: SelectionNode<any> | undefined,\n  defaultSelection: SelectionNode<TreeNode> | undefined,\n  depth: number,\n  output: NodeEntry[]\n) {\n  const expanded = isItemExpanded(props, item);\n  output.push({\n    type: EntryType.Node,\n    depth,\n    item,\n    itemSelection,\n    defaultSelection,\n    expanded,\n  });\n\n  if (expanded) {\n    const defaultSelectionForChildren =\n      itemSelection && TreeSelection.isTerminal(itemSelection) ? itemSelection : defaultSelection;\n    describeChildren(props, item, itemSelection, defaultSelectionForChildren, depth + 1, output);\n  }\n}\n\nfunction isItemExpanded(props: LazyTreeSelectorProps, item: TreeNode): boolean {\n  let expanded: boolean | undefined = props.isExpanded(item);\n  if (expanded === undefined) {\n    expanded = props.expandedByDefault;\n  }\n  return expanded === undefined ? false : expanded;\n}\n"],"sourceRoot":""}