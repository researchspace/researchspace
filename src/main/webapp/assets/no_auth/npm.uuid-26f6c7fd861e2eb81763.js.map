{"version":3,"sources":["webpack:///./node_modules/uuid/uuid.js","webpack:///./node_modules/uuid/rng-browser.js"],"names":["_rng","_byteToHex","_hexToByte","i","toString","substr","unparse","buf","offset","bth","_seedBytes","_nodeId","_clockseq","_lastMSecs","_lastNSecs","v4","options","Array","rnds","random","rng","ii","uuid","v1","b","clockseq","undefined","msecs","Date","getTime","nsecs","dt","Error","tl","tmh","node","n","parse","s","toLowerCase","replace","oct","module","exports","crypto","global","msCrypto","getRandomValues","_rnds8","Uint8Array","whatwgRNG","_rnds","r","Math"],"mappings":"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","file":"npm.uuid-26f6c7fd861e2eb81763.js","sourcesContent":["//     uuid.js\n//\n//     Copyright (c) 2010-2012 Robert Kieffer\n//     MIT License - http://opensource.org/licenses/mit-license.php\n\n// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0, ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0, bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; n++) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : unparse(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ii++) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || unparse(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\nuuid.parse = parse;\nuuid.unparse = unparse;\n\nmodule.exports = uuid;\n","\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n"],"sourceRoot":""}