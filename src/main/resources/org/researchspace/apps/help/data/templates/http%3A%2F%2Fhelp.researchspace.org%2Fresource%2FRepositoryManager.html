<div class="page__grid-container help-page-container">
  <div class='page__content-container'>
    <h1>Repository manager</h1>
    <p>The ResearchSpace platform works with the knowledge graph data stored in RDF repositories. 
      By default, the platform works with one specific repository, but it is able to access data 
      from as many repositories as needed. For example, while the main knowledge graph is stored 
      in the default repository, it may be necessary to retrieve and display linked data from 
      external public data sources or to maintain auxiliary internal information (such as saved user 
      queries from the query catalog) separately from the main domain knowledge. For this reason, 
      the ResearchSpace platform has to be able to connect to multiple data sources. 
      The platform at <semantic-link iri="http://localhost:10214/resource/Admin:Repositories" 
      class="text-link-action" target="_blank">http://localhost:10214/resource/Admin:Repositories</semantic-link> 
      is used to configure and maintain these connections.</p>
    
    <hr class="divider">
    <h2>Repository configurations</h2>
    <p>The platform reuses the 
      <a href='http://rdf4j.org/' class="text-link-action" target="_blank">RDF4J framework</a> 
      to configure the connections to RDF repositories. Each repository maintained by the 
      Repository Manager is referenced by a 
      string ID and its type and configuration parameters are described as an RDF graph 
      using the RDF4J repository configuration 
      format (see example below). Each 
      configuration RDF graph must include an instance of type <i>config:Repository</i> 
      with the following mandatory properties:</p> 
    <ul>
      <li><code>config:rep.id</code>: the ID of the repository.</li>
      <li><code>rdfs:label</code>: a human-readable description of the repository. </li>
      <li><code>config:rep.impl</code>: a link to the <i>repository 
        implementation resource</i> defining the specific implementation of the 
        concrete repository type.</li>
    </ul>
    <p>The repository implementation resource, in turn, must have one mandatory property:</p>
    <ul>
      <li><code>config:rep.type</code>: A string identifier of the specific 
        implementation type of the repository (e.g., a SPARQL endpoint or a native 
        RDF4J repository storing data locally on disk).</li>
    </ul>
    <p>Each repository type determines which other configuration properties 
      are required: for example, for a SPARQL endpoint one has to specify 
      the URL of the query endpoint, for a native RDF4J repository one has to 
      include the types of statement indices, etc.</p>
    
    <div class="alert alert-info">
      <strong>Note:</strong> Starting with RDF4J 5.0, the configuration vocabulary has changed. 
      The old vocabulary (<code>http://www.openrdf.org/config/repository#</code>) is still supported 
      for backward compatibility but is deprecated. New configurations should use the new vocabulary 
      (<code>tag:rdf4j.org,2023:config/repository#</code>).
    </div>

    <mp-code-block mode="text/turtle">
    <![CDATA[
@prefix config: <tag:rdf4j.org,2023:config/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix mph: <http://www.researchspace.org/resource/system/repository#> .

[] a config:Repository ;
  config:rep.id "default" ;
	rdfs:label "Default HTTP SPARQL Repository" ;
	config:rep.impl [
		config:rep.type "researchspace:SPARQLRepository" ;
		config:sparql.queryEndpoint <http://example.org/sparql> ;
	] .
]]>
    </mp-code-block>
    <p>The platform stores configurations of repositories in the <code>config/repositories</code> 
      subdirectory of its installation location. Each repository configuration is stored in a 
      separate file named <code>{Repository ID}.ttl</code> in the RDF/Turtle format. Note that 
      the repository ID in the file name must match the one defined in the configuration graph. 
      The configuration files can be edited either directly on the disk or using the platform 
      <semantic-link iri="http://localhost:10214/resource/Admin:Repositories" 
      class="text-link-action" target="_blank">Admin:Repositories</semantic-link>. 
      The platform reads the repository configuration files and initializes the repositories once at 
      startup time. After adding or modifying a repository configuration, 
      the system must be restarted for the changes to take effect.</p>
    
    <p>The platform has the following reserved repository IDs:</p>
    <ul>
      <li><i>default</i>: denotes the main repository. By default, all SPARQL queries 
        are answered from this repository and all UI components are working with this 
        repository.</li>
      <li><i>assets</i>: auxiliary repository containing platform-internal metadata. 
        This includes, for example, query templates stored in the query catalog, 
        definition of fields, etc.</li>
    </ul>
    
    <p>The configuration of these repositories can still be changed using the configuration Turtle
       files. However, in the absence of explicit configuration files the platform assumes that 
       the default repository represents a SPARQL endpoint. Its URL is taken from the value of 
       the <code>sparqlEndpoint</code> property in the <code>environment.prop</code> file. 
       As the assets repository, the platform by default uses a native RDF4J repository 
       storing its information locally in the subfolder <code>data/repositories/assets</code>.</p>
    
    <hr class="divider">
    <h2>Commonly used repository types</h2>
    <p>This section lists some of the commonly used repository types and provides example configurations.</p>
    
    <br>
    <h3>SPARQL repository</h3>
    <p>This is probably the most common type of the repository representing a SPARQL endpoint running separately from the platform. The platform communicates with such repositories via the HTTP protocol. In the ResearchSpace platform, such repositories are described using repository type <code>researchspace:SPARQLRepository</code>.</p>
    <mp-code-block mode="text/turtle"><![CDATA[
@prefix config: <tag:rdf4j.org,2023:config/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix mph: <http://www.researchspace.org/resource/system/repository#> .

[] a config:Repository ;
	config:rep.id "default" ;
	rdfs:label "Default HTTP SPARQL Repository" ;
	config:rep.impl [
		config:rep.type "researchspace:SPARQLRepository" ;
		config:sparql.queryEndpoint <http://example.org/sparql> ; # Endpoint to send SPARQL queries to.
		config:sparql.updateEndpoint <http://example.org/update> ; # Update endpoint (optional - only if different from the query endpoint)
		mph:quadMode true ; # Flag determining whether the requests for statements should retrieve triples <subj, pred, obj> or quads <subj, pred, obj, named_graph>
	] .
]]>
    </mp-code-block>
    <p>Occasionally, a remote SPARQL repository can require authentication using, 
      for example, basic authentication or digest access authentication. 
      Such repositories should be configured using special modifications of the 
      generic SPARQL repository: <code>researchspace:SPARQLBasicAuthRepository</code> 
      and <code>researchspace:SPARQLDigestAuthRepository</code>. These repository 
      implementations accept the following additional configuration parameters:</p>
    <ul>
      <li><code>mph:username</code></li>
      <li><code>mph:password</code></li>
      <li><code>mph:realm</code> (only for <i>researchspace:SPARQLDigestAuthRepository</i>)</li>
    </ul>
    
    <p>
    Credentials can be provided directly (i.e. in clear text) or in 
    externalized form using placeholders which are replaced by 
    so-called <code>SecretResolvers</code>. 
    The key names used in the placeholders can be chosen freely.<br/> 
    Example:
    </p>
    <ul>
      <li><code>mph:username=${repository.username:admin}</code></li>
      <li><code>mph:password=${repository.password}</code></li>
      <li><code>mph:realm=${repository.realm}</code></li>
    </ul>
    
    <hr class="divider">
    <h3>RDF4J native repository</h3>
    <p>The RDF4J native repository is a special RDF4J implementation 
      of a local triple store, which runs in the same process as the 
      user application and stores the data on disk. The platform 
      keeps the storage files of the repository in the subfolder 
      <code>data/repositories/{repository ID}</code>.</p>
    
    <mp-code-block mode="text/turtle"><![CDATA[
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix config: <tag:rdf4j.org,2023:config/> .

[] a config:Repository ;
  config:rep.id "default" ; # Replace with your repository ID
  rdfs:label "Native store" ; 
  config:rep.impl [
    config:rep.type "openrdf:SailRepository" ;
    config:sail.impl [
      config:sail.type "openrdf:NativeStore" ;
      config:native.iterationCacheSyncThreshold "0"; # Threshold for syncing query evaluation iteration caches to disk
      config:native.tripleIndexes "spoc,posc" # Triple indices
    ]
  ].
]]>
    </mp-code-block>
    
    <p>Most of the state-of-the-art triple stores available on the
       market now outperform the RDF4J native repository. 
      For this reason, RDF4J native repository should only be 
      used in scenarios involving small amount of data.</p>
    
    <hr class="divider">
    <h3>Neptune SPARQL repository</h3>
    <p>The recently introduced <a href='https://aws.amazon.com/neptune/' class="text-link-action" target="_blank">Amazon 
      Neptune database</a> 
      provides a graph database solution optimized for running in a cluster environment. 
      While it is a special case of a SPARQL repository, it requires its own special 
      handling for data loading operations. </p>
    <mp-code-block mode="text/turtle"><![CDATA[
@prefix config: <tag:rdf4j.org,2023:config/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix mph: <http://www.researchspace.org/resource/system/repository#> .

[] a config:Repository ;
  config:rep.id "default" ; # Replace with your repository ID
  rdfs:label "Amazon Neptune repository" ;
  config:rep.impl [
    config:rep.type "researchspace:NeptuneSPARQLRepository" ;
    config:sparql.queryEndpoint <http://example.org/query> ;
    mph:neptuneDataLoaderUrl <http://example.org/loader>; # Data loader endpoint to be used for bulk loading of the data from an S3 bucket.
    mph:quadMode "true"
  ].
]]>
    </mp-code-block>
    
    <hr class="divider">
    <h3>Ephedra federation repository</h3>
    Ephedra is a 
    SPARQL query federation architecture that is able to send federated 
    queries over several repositories registered in the Repository Manager.
    It is built on top of FedX and adds support for REST services and query hints.
    <mp-code-block mode='text/turtle'>
    <![CDATA[
@prefix config: <tag:rdf4j.org,2023:config/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix mph: <http://www.researchspace.org/resource/system/repository#> .
@prefix mps: <http://www.researchspace.org/resource/system/service#> .
@prefix mpf: <http://www.researchspace.org/resource/system/repository/federation#> .
@prefix ephedra: <http://www.researchspace.org/resource/system/ephedra#> .
@prefix fedx: <http://rdf4j.org/config/federation#> .

[] a config:Repository ;
    config:rep.id "ephedra" ;
    rdfs:label "Local Ephedra federation" ;
    config:rep.impl [
      config:rep.type "researchspace:FederationSailRepository" ;
      config:sail.impl [
          config:sail.type "researchspace:Federation" ;
          mph:defaultMember "default" ; # Repository ID of the default member of the federation
          config:fed.member [
            ephedra:delegateRepositoryID "{%Repository ID of the federation member|wikidata-text%}" ;
            ephedra:serviceReference {%URI to reference this federation member in a SERVICE clause|mpf:wikidata-text%}
          ] ;
          config:fed.member [
            ephedra:delegateRepositoryID "{%Repository ID of the federation member|assets%}" ;
            ephedra:serviceReference {%URI to reference this federation member in a SERVICE clause|mpf:assets%}
          ] ;
          
          # Optional: FedX configuration
          fedx:config [
            fedx:enforceMaxQueryTime 120 ;    # Query timeout in seconds (default: 120)
            fedx:joinWorkerThreads 20 ;       # Parallel join threads (default: 20)
            fedx:debugQueryPlan false         # Print query plan to stdout (default: false)
          ]
      ] 
    ] .
      ]]>
    </mp-code-block>
    
    <h4>Ephedra Configuration Properties</h4>
    <p>Ephedra supports all standard FedX configuration properties via the <code>fedx:config</code> block:</p>
    <table class="table table-striped">
      <thead>
        <tr><th>Property</th><th>Default</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr><td><code>fedx:enforceMaxQueryTime</code></td><td><strong>120</strong></td><td>Query timeout in seconds (0 = disabled). ResearchSpace default is 120s.</td></tr>
        <tr><td><code>fedx:joinWorkerThreads</code></td><td>20</td><td>Thread pool size for parallel join operations</td></tr>
        <tr><td><code>fedx:unionWorkerThreads</code></td><td>20</td><td>Thread pool size for parallel union operations</td></tr>
        <tr><td><code>fedx:leftJoinWorkerThreads</code></td><td>10</td><td>Thread pool size for LEFT JOIN operations</td></tr>
        <tr><td><code>fedx:boundJoinBlockSize</code></td><td>25</td><td>Number of bindings per VALUES clause in bound join</td></tr>
        <tr><td><code>fedx:enableServiceAsBoundJoin</code></td><td>true</td><td>Use VALUES clause for SERVICE evaluation</td></tr>
        <tr><td><code>fedx:enableMonitoring</code></td><td>false</td><td>Enable monitoring features</td></tr>
        <tr><td><code>fedx:debugQueryPlan</code></td><td>false</td><td>Print optimized query plan to stdout</td></tr>
        <tr><td><code>fedx:logQueryPlan</code></td><td>false</td><td>Log query plan via QueryPlanLog</td></tr>
        <tr><td><code>fedx:sourceSelectionCacheSpec</code></td><td>-</td><td>Guava CacheBuilderSpec for source selection cache</td></tr>
      </tbody>
    </table>
    
    <h4>Ephedra-Specific Configuration</h4>
    <p>In addition to FedX properties, Ephedra supports these configuration options directly on the SAIL:</p>
    <table class="table table-striped">
      <thead>
        <tr><th>Property</th><th>Default</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr><td><code>ephedra:restServicePrefetchSize</code></td><td>5</td><td>Number of parallel HTTP calls for REST services. Higher values improve performance but may make slightly more calls than needed when LIMIT is used.</td></tr>
        <tr><td><code>ephedra:enableQueryHints</code></td><td>true</td><td>Enable query hint annotations for join reordering</td></tr>
      </tbody>
    </table>
    
    <h4>REST Service Handling</h4>
    <p>Ephedra automatically detects REST-backed services and uses <strong>bounded prefetching</strong> to balance parallelism with LIMIT awareness. 
    It maintains up to <code>restServicePrefetchSize</code> HTTP calls in-flight at any time. When <code>LIMIT</code> is reached, 
    pending calls are cancelled. This ensures fast execution while respecting LIMIT clauses.</p>
    
    <div class="alert alert-info">
      <strong>Example:</strong> With <code>ephedra:restServicePrefetchSize 5</code> and <code>LIMIT 20</code>:
      <ul>
        <li>Best case: ~20 HTTP calls</li>
        <li>Worst case: ~25 HTTP calls (20 + 5 prefetched)</li>
        <li>~5x faster than sequential execution!</li>
      </ul>
    </div>
    
    <div class="alert alert-warning">
      <strong>ORDER BY Limitation:</strong> When using <code>ORDER BY</code> on a variable that comes from a REST service result, 
      all HTTP calls must be made before sorting can occur. This defeats the lazy evaluation optimization. 
      To benefit from LIMIT optimization with REST services, avoid <code>ORDER BY</code> on REST result variables, 
      or perform sorting client-side. See the <semantic-link iri="[[resolvePrefix 'Help:RESTSail']]" class="text-link-action">REST Sail documentation</semantic-link> for details.
    </div>
    
    <hr class="divider">
    <h3>FedX federation repository</h3>
    <p>
      FedX provides transparent federation of multiple SPARQL endpoints under a single virtual endpoint.
      In a federated SPARQL query in FedX, one no longer needs to explicitly address specific endpoints using SERVICE clauses.
      Instead, FedX automatically selects relevant sources, sends statement patterns to these sources for evaluation, and joins the individual results.
    </p>
    <p>
      FedX can be used as a drop-in component in existing applications. Below is an example configuration that federates the default repository with Wikidata.
    </p>
    <mp-code-block mode="text/turtle">
    <![CDATA[
@prefix config: <tag:rdf4j.org,2023:config/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix fedx: <http://rdf4j.org/config/federation#> .
@prefix sd: <http://www.w3.org/ns/sparql-service-description#> .

[] a config:Repository ;
    config:rep.id "fedx" ;
    rdfs:label "FedX Federation" ;
    config:rep.impl [
        config:rep.type "fedx:FedXRepository" ;
        fedx:member [
            fedx:store "ResolvableRepository" ;
            fedx:repositoryName "default"
        ] ;
        fedx:member [
            fedx:store "SPARQLEndpoint" ;
            sd:endpoint "https://query.wikidata.org/sparql"
        ] ;
        fedx:member [
            fedx:store "SPARQLEndpoint" ;
            sd:endpoint "https://artresearch.net/sparql"
        ]
    ] .
    ]]>
    </mp-code-block>

    <p>
      FedX repositories can also be configured with various options to control query execution and monitoring.
      For example, you can set the number of worker threads or enforce a maximum query time.
    </p>
    <mp-code-block mode="text/turtle">
    <![CDATA[
   config:rep.impl [
      config:rep.type "fedx:FedXRepository" ;
      # ... members ...
      fedx:config [
         fedx:joinWorkerThreads 20 ;
         fedx:enforceMaxQueryTime 30 ;
         fedx:enableMonitoring true ;
         fedx:logQueryPlan true ;
      ]
   ] .
    ]]>
    </mp-code-block>

    <h4>Using FedX with Ephedra</h4>
    <p>
      FedX can be used in conjunction with Ephedra. A common pattern is to use a FedX repository as the default member of an Ephedra federation.
      This allows Ephedra to handle specific services (like search services) while delegating general SPARQL queries to the FedX federation, which then distributes them across its members.
    </p>
    <mp-code-block mode="text/turtle">
    <![CDATA[
@prefix config: <tag:rdf4j.org,2023:config/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix mph: <http://www.researchspace.org/resource/system/repository#> .
@prefix ephedra: <http://www.researchspace.org/resource/system/ephedra#> .

[] a config:Repository;
  config:rep.id "wikidata-ephedra";
  rdfs:label "Wikidata Ephedra Federation";
  config:rep.impl [
      config:rep.type "researchspace:FederationSailRepository";
      config:sail.impl [
          config:sail.type "researchspace:Federation";
          # Define Ephedra services
          config:fed.member [
              ephedra:delegateRepositoryID "osm-nominatim-search";
              ephedra:serviceReference <http://www.researchspace.org/resource/system/services/osm/NominatimSearchService>
            ],
            [
              ephedra:delegateRepositoryID "wikidata-entity";
              ephedra:serviceReference <http://www.researchspace.org/resource/system/service/wikidataentity/WikidataEntity>
            ];
          # Use FedX as the default member
          ephedra:defaultMember "fedx"
        ]
    ] .
    ]]>
    </mp-code-block>

    <p>
      This configuration enables complex federated workflows. For example, you can search for a place using Nominatim, get its details from Wikidata, and then find artworks located in that place from ArtResearch.net (which uses CIDOC-CRM) - all in a <strong>single federated query</strong>:
    </p>

    <mp-code-block mode="application/sparql-query">
    <![CDATA[
PREFIX osm: <http://www.researchspace.org/resource/system/services/osm/>
PREFIX wdt: <http://www.wikidata.org/prop/direct/>
PREFIX schema: <http://schema.org/>
PREFIX crm: <http://www.cidoc-crm.org/cidoc-crm/>

SELECT ?placeName ?wikidataId ?description ?pharosPlaceLabel WHERE {
  # 1. Search for "Venice" using Nominatim Service (via Ephedra)
  SERVICE <http://www.researchspace.org/resource/system/services/osm/NominatimSearchService> {
    ?place osm:q "Venice" ;
           osm:wikidata ?wikidataId ;
           osm:display_name ?placeName .
  }

  # 2. Convert the Wikidata ID string (e.g., "Q641") to an IRI
  BIND(IRI(CONCAT("http://www.wikidata.org/entity/", ?wikidataId)) AS ?wikidataEntity)

  # 3. Query Wikidata (via FedX) for description and TGN ID (P1667)
  ?wikidataEntity schema:description ?description ;
                  wdt:P1667 ?tgnId .
  FILTER(LANG(?description) = "en")

  # 4. Construct TGN URI
  BIND(IRI(CONCAT("http://vocab.getty.edu/tgn/", ?tgnId)) AS ?tgnUri)
  
  # 5. Query ArtResearch.net (via FedX) for label that is used there for Venice
  {
    ?tgnUri <http://www.cidoc-crm.org/cidoc-crm/P1_is_identified_by> ?id. 
    ?id <http://www.cidoc-crm.org/cidoc-crm/P2_has_type> <https://artresearch.net/resource/pharos/vocab/meta/pharos_preferred_name> . 
    ?id <http://www.cidoc-crm.org/cidoc-crm/P190_has_symbolic_content> ?pharosPlaceLabel .
  }
} LIMIT 10
    ]]>
    </mp-code-block>

    <hr class="divider">
    <h3>Virtuoso repository</h3>
    <p><a href='https://virtuoso.openlinksw.com/' class="text-link-action" target="_blank">Virtuoso</a> is 
      a popular state of the art triple store used in many use case scenarios. 
      To use a Virtuoso repository with the platform, a standard configuration 
      for SPARQL repositories can be used. However, Virtuoso triple stores 
      have certain distinctions in the way they support SPARQL queries. 
      Most notably, Virtuoso does not process correctly SPARQL 1.1 ASK queries 
      sent via the endpoint. To overcome this, in the platform repository 
      manager a special Virtuoso Wrapper repository should be configured. 
      This wrapper repository does not provide a standalone repository instance, 
      but must be used as a proxy to a separately configured SPARQL repository 
      representing the Virtuoso triple store. This proxy will adapt the queries 
      sent to it to transform them into the format accepted by Virtuoso. 
      An example configuration of a wrapper repository is provided below.
    </p>
    
    <mp-code-block mode="text/turtle">
    <![CDATA[
@prefix config: <tag:rdf4j.org,2023:config/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix mph: <http://www.researchspace.org/resource/system/repository#> .

[] a config:Repository ;
  config:rep.id "default" ;
  rdfs:label "Test Virtuoso SPARQL repository wrapper" ;
  config:rep.impl [ 
    config:rep.type "researchspace:VirtuosoWrapperRepository" ;
    mph:delegateRepositoryID "{Virtuoso Repository ID}" ;
  ] .
      ]]>
    </mp-code-block>
    <p>This configuration defines a wrapper repository which 
      serves as a proxy to another one: a SPARQL repository 
      denoted by <code>{Virtuoso Repository ID}</code>.</p>
  </div>
</div>