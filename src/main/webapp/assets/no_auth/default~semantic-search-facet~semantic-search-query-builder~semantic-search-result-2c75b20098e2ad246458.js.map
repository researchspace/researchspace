{"version":3,"sources":["webpack:///./src/main/web/components/semantic/search/data/search/SparqlQueryGenerator.ts"],"names":["DEFAULT_QUERY_PATTERN","resultProjectinVar","SEMANTIC_SEARCH_VARIABLES","RELATION_VAR","RESOURCE_VAR","DEFAULT_SET_QUERY_PATTERN","SET_VAR","vocabularies","ldp","contains","VocabPlatform","setItem","resourceDisjunct","disjunct","value","iri","setDisjunct","disjucnct","textDisjunct","config","conjunct","patternConfig","getConfigPatternForCategory","range","val","SparqlUtil","makeLuceneQuery","escapeLuceneSyntax","tokenizeLuceneQuery","dateDisjunct","DATE_BEGING_VAR","createDateLiteral","DATE_END_VAR","dateRangeDisjunct","begin","end","dateDeviationDisjunct","date","deviation","clone","subtract","add","yearDisjunct","yearValue","year","epoch","moment","month","day","yearRangeDisjunct","yearStartValue","beginValue","yearEndValue","endValue","yearDeviationDisjunct","yearFullDate","startOf","endOf","distanceDisjunct","GEO_CENTER_VAR","createGeoLiteral","center","GEO_CENTER_LAT_VAR","Rdf","literal","lat","GEO_CENTER_LONG_VAR","long","GEO_DISTANCE_VAR","distance","boundingBoxDisjunct","GEO_SOUTH_WEST","southWest","GEO_SOUTH_WEST_LAT","GEO_SOUTH_WEST_LONG","GEO_NORTH_EAST","northEast","GEO_NORTH_EAST_LAT","GEO_NORTH_EAST_LONG","literalDisjunct","LITERAL_VAR","numericRangeDisjunct","dataType","kind","datatype","NUMERIC_RANGE_BEGIN_VAR","NUMERIC_RANGE_END_VAR","format","xsd","fixZeroYearIssue","coord","replace","toString","tryGetRelationPatterns","relation","hasRange","_","has","relations","categories","applySetPattern","relationPattern","setPattern","subjectVariable","rewriteSubjectVariable","variablesMap","variableTerm","variable","this","uuid","v4","QueryVisitor","randomizeVariables","query","Randomizer","disjunctToQueryPattern","projectionVariable","domain","Model","EntityDisjunctKinds","Search","complexDisjunctToQueryPattern","nestedQuery","generateSelectQueryPattern","search","patterns","conjunctsToQueryPatterns","conjuncts","prefixes","type","queryType","variables","where","nestedQueryPattern","SavedSearch","simpleDisjunctToQueryPattern","simpleDisjunctPatternQuery","patternQuery","unshift","queryPattern","getMatchingPatternConfig","matchConjunct","Relation","conj","length","isSetDisjunct","isTemporalDisjunct","find","pattern","isSpatialDisjunct","hierarchyPattern","resourcePattern","literalPattern","numericRangePattern","Text","SpatialDisjunctKinds","Distance","distanceQueryPattern","BoundingBox","boundingBoxQueryPattern","parsedPattern","parseQueryPattern","rewriteProjectionVariable","parseQuerySync","parameters","assign","getGenericVariables","DOMAIN_VAR","RANGE_VAR","disjunctToVariables","matchDisjunct","Resource","Set","Date","DateRange","DateDeviation","Year","YearRange","YearDeviation","Literal","NumericRange","SparqlClient","setBindings","conjunctToQueryPattern","map","disjuncts","flattenedPatterns","SparqlTypeGuards","isBlockPattern","flatten","isGroupPattern","result","cloneQuery","substring","PROJECTION_ALIAS_VAR","generateFederatedQueryPatterns","datasets","unionPatterns","dataset","generatePatternForDataset","whereClause","federated","undefined","id","wrapIntoService","serviceUrl","silent","name","generateNonFederatedPatternForDataset","datasetPattern","Maybe","fromNullable","chain","c","getOrElse","parsePatterns","concat","__dataset__","generateSelectQuery","projectionVariableName","distinct","limit","blazegraphNoOptimizePattern","triples","subject","predicate","object","generateQueryForMultipleDatasets","federatedPatterns"],"mappings":"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","file":"default~semantic-search-facet~semantic-search-query-builder~semantic-search-result-2c75b20098e2ad246458.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2020, Â© Trustees of the British Museum\n * Copyright (C) 2015-2019, metaphacts GmbH\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as moment from 'moment';\nimport * as uuid from 'uuid';\nimport * as _ from 'lodash';\nimport * as SparqlJs from 'sparqljs';\nimport * as Maybe from 'data.maybe';\n\nimport { Rdf, vocabularies } from 'platform/api/rdf';\nimport { SparqlUtil, SparqlClient, QueryVisitor, SparqlTypeGuards, cloneQuery } from 'platform/api/sparql';\nimport * as Model from './Model';\nimport { Dataset } from '../datasets/Model';\nimport {\n  SemanticSearchConfig,\n  SEMANTIC_SEARCH_VARIABLES,\n  PatternConfig,\n  Resource,\n  Hierarchy,\n  Text,\n  Set,\n  getConfigPatternForCategory,\n  Place,\n  DateRange,\n  Literal,\n  NumericRange,\n  DatasetsConfig,\n} from '../../config/SearchConfig';\n\nconst XSD_DATE_FORMAT = 'YYYY-MM-DD';\n\nfunction DEFAULT_QUERY_PATTERN(resultProjectinVar: string) {\n  return `${resultProjectinVar} ?${SEMANTIC_SEARCH_VARIABLES.RELATION_VAR} ?${SEMANTIC_SEARCH_VARIABLES.RESOURCE_VAR} .`;\n}\n\nconst DEFAULT_SET_QUERY_PATTERN = `\n   ?${SEMANTIC_SEARCH_VARIABLES.SET_VAR} ${vocabularies.ldp.contains}/${vocabularies.VocabPlatform.setItem} ?${SEMANTIC_SEARCH_VARIABLES.RESOURCE_VAR} .\n`;\nfunction resourceDisjunct(disjunct: Model.ResourceDisjunct) {\n  return { [SEMANTIC_SEARCH_VARIABLES.RESOURCE_VAR]: disjunct.value.iri };\n}\n\nfunction setDisjunct(disjucnct: Model.SetDisjunct) {\n  return { [SEMANTIC_SEARCH_VARIABLES.SET_VAR]: disjucnct.value.iri };\n}\n\nfunction textDisjunct(config: SemanticSearchConfig, conjunct: Model.Conjunct) {\n  const patternConfig = (getConfigPatternForCategory(config, conjunct.range.iri) || {}) as Text;\n  return function (disjunct: Model.TextDisjunct) {\n    const val = SparqlUtil.makeLuceneQuery(\n      disjunct.value,\n      patternConfig.escapeLuceneSyntax,\n      patternConfig.tokenizeLuceneQuery\n    );\n    return { [SEMANTIC_SEARCH_VARIABLES.RESOURCE_VAR]: val };\n  };\n}\n\nfunction dateDisjunct(config: PatternConfig) {\n  return function (disjunct: Model.DateDisjunct) {\n    return {\n      [SEMANTIC_SEARCH_VARIABLES.DATE_BEGING_VAR]: createDateLiteral(disjunct.value, config),\n      [SEMANTIC_SEARCH_VARIABLES.DATE_END_VAR]: createDateLiteral(disjunct.value, config),\n    };\n  };\n}\n\nfunction dateRangeDisjunct(config: PatternConfig) {\n  return function (disjunct: Model.DateRangeDisjunct) {\n    return {\n      [SEMANTIC_SEARCH_VARIABLES.DATE_BEGING_VAR]: createDateLiteral(disjunct.value.begin, config),\n      [SEMANTIC_SEARCH_VARIABLES.DATE_END_VAR]: createDateLiteral(disjunct.value.end, config),\n    };\n  };\n}\n\nfunction dateDeviationDisjunct(config: PatternConfig) {\n  return function (disjunct: Model.DateDeviationDisjunct) {\n    const { date, deviation } = disjunct.value;\n    return {\n      [SEMANTIC_SEARCH_VARIABLES.DATE_BEGING_VAR]: createDateLiteral(date.clone().subtract(deviation, 'days'), config),\n      [SEMANTIC_SEARCH_VARIABLES.DATE_END_VAR]: createDateLiteral(date.clone().add(deviation, 'days'), config),\n    };\n  };\n}\n\nfunction yearDisjunct(config: PatternConfig) {\n  return function (disjunct: Model.YearDisjunct) {\n    const { year, epoch } = disjunct.value;\n    const yearValue = year * (epoch === 'AD' ? 1 : -1);\n    const begin = moment({ year: yearValue, month: 0, day: 1 });\n    const end = moment({ year: yearValue, month: 11, day: 31 });\n    return {\n      [SEMANTIC_SEARCH_VARIABLES.DATE_BEGING_VAR]: createDateLiteral(begin, config),\n      [SEMANTIC_SEARCH_VARIABLES.DATE_END_VAR]: createDateLiteral(end, config),\n    };\n  };\n}\n\nfunction yearRangeDisjunct(config: PatternConfig) {\n  return function (disjunct: Model.YearRangeDisjunct) {\n    const { begin, end } = disjunct.value;\n    const yearStartValue = begin.year * (begin.epoch === 'AD' ? 1 : -1);\n    const beginValue = moment({ year: yearStartValue, month: 0, day: 1 });\n    const yearEndValue = end.year * (end.epoch === 'AD' ? 1 : -1);\n    const endValue = moment({ year: yearEndValue, month: 11, day: 31 });\n    return {\n      [SEMANTIC_SEARCH_VARIABLES.DATE_BEGING_VAR]: createDateLiteral(beginValue, config),\n      [SEMANTIC_SEARCH_VARIABLES.DATE_END_VAR]: createDateLiteral(endValue, config),\n    };\n  };\n}\n\nfunction yearDeviationDisjunct(config: PatternConfig) {\n  return function (disjunct: Model.YearDeviationDisjunct) {\n    const { year, deviation } = disjunct.value;\n    const yearValue = year.year * (year.epoch === 'AD' ? 1 : -1);\n    const yearFullDate = moment({ year: yearValue });\n    const begin = yearFullDate.clone().startOf('year').subtract(deviation, 'years');\n    const end = yearFullDate.clone().endOf('year').add(deviation, 'years');\n    return {\n      [SEMANTIC_SEARCH_VARIABLES.DATE_BEGING_VAR]: createDateLiteral(begin, config),\n      [SEMANTIC_SEARCH_VARIABLES.DATE_END_VAR]: createDateLiteral(end, config),\n    };\n  };\n}\n\nfunction distanceDisjunct(config: PatternConfig) {\n  return function (disjunct: Model.SpatialDistanceDisjunct) {\n    return {\n      [SEMANTIC_SEARCH_VARIABLES.GEO_CENTER_VAR]: createGeoLiteral(disjunct.value.center, config),\n      [SEMANTIC_SEARCH_VARIABLES.GEO_CENTER_LAT_VAR]: Rdf.literal(`${disjunct.value.center.lat}`),\n      [SEMANTIC_SEARCH_VARIABLES.GEO_CENTER_LONG_VAR]: Rdf.literal(`${disjunct.value.center.long}`),\n      [SEMANTIC_SEARCH_VARIABLES.GEO_DISTANCE_VAR]: Rdf.literal(disjunct.value.distance),\n    };\n  };\n}\n\nfunction boundingBoxDisjunct(config: PatternConfig) {\n  return function (disjunct: Model.SpatialBoundingBoxDisjunct) {\n    return {\n      [SEMANTIC_SEARCH_VARIABLES.GEO_SOUTH_WEST]: createGeoLiteral(disjunct.value.southWest, config),\n      [SEMANTIC_SEARCH_VARIABLES.GEO_SOUTH_WEST_LAT]: Rdf.literal(`${disjunct.value.southWest.lat}`),\n      [SEMANTIC_SEARCH_VARIABLES.GEO_SOUTH_WEST_LONG]: Rdf.literal(`${disjunct.value.southWest.long}`),\n      [SEMANTIC_SEARCH_VARIABLES.GEO_NORTH_EAST]: createGeoLiteral(disjunct.value.northEast, config),\n      [SEMANTIC_SEARCH_VARIABLES.GEO_NORTH_EAST_LAT]: Rdf.literal(`${disjunct.value.northEast.lat}`),\n      [SEMANTIC_SEARCH_VARIABLES.GEO_NORTH_EAST_LONG]: Rdf.literal(`${disjunct.value.northEast.long}`),\n    };\n  };\n}\n\nfunction literalDisjunct(disjunct: Model.LiteralDisjunct) {\n  return {\n    [SEMANTIC_SEARCH_VARIABLES.LITERAL_VAR]: disjunct.value.literal,\n  };\n}\n\nfunction numericRangeDisjunct(config: PatternConfig) {\n  return function (disjunct: Model.NumericRangeDisjunct) {\n    let dataType = Rdf.iri('http://www.w3.org/2001/XMLSchema#double');\n    if (config.kind === 'numeric-range' && config.datatype) {\n      dataType = Rdf.iri(config.datatype);\n    }\n    return {\n      [SEMANTIC_SEARCH_VARIABLES.NUMERIC_RANGE_BEGIN_VAR]: Rdf.literal('' + disjunct.value.begin, dataType),\n      [SEMANTIC_SEARCH_VARIABLES.NUMERIC_RANGE_END_VAR]: Rdf.literal('' + disjunct.value.end, dataType),\n    };\n  };\n}\n\nfunction createDateLiteral(date: moment.Moment, config: PatternConfig): Rdf.Literal {\n  let format = XSD_DATE_FORMAT;\n  let dataType = vocabularies.xsd.date;\n  if (config.kind === 'date-range') {\n    if (config.datatype) {\n      dataType = Rdf.iri(config.datatype);\n    }\n\n    if (config.format) {\n      format = config.format;\n    }\n  }\n  return Rdf.literal(fixZeroYearIssue(date).format(format), dataType);\n}\n\nfunction createGeoLiteral(coord: Model.Coordinate, config: PatternConfig) {\n  let value = `${coord.lat}#${coord.long}`;\n  let dataType: Rdf.Iri;\n  if (config.kind === 'place') {\n    if (config.format) {\n      value = config.format.replace('lat', coord.lat.toString()).replace('long', coord.long.toString());\n    }\n    if (config.datatype) {\n      dataType = Rdf.iri(config.datatype);\n    }\n  }\n  return Rdf.literal(value, dataType);\n}\n\n/**\n * blazegraph uses RDF 1.0 specification, wihch refers to\n * - http://www.w3.org/TR/xmlschema-2/#year-zero\n * where 0000 year is invalid.\n *\n * Use of this method should be removed as soon as bigdata update to RDF 1.1,\n * where 0000 year is valid date - http://www.w3.org/TR/xmlschema11-2/#dateTime\n *\n * @see https://jira.blazegraph.com/browse/BLZG-1199\n */\nfunction fixZeroYearIssue(date: moment.Moment) {\n  return date.year() === 0 ? date.subtract(1, 'year') : date;\n}\n\nfunction disjunctToVariables(config: SemanticSearchConfig, patternConfig: PatternConfig, conjunct: Model.Conjunct) {\n  return Model.matchDisjunct<Record<string, Rdf.Node>>({\n    Resource: resourceDisjunct,\n    Set: setDisjunct,\n    Search: () => ({}),\n    SavedSearch: () => ({}),\n    Date: dateDisjunct(patternConfig),\n    DateRange: dateRangeDisjunct(patternConfig),\n    DateDeviation: dateDeviationDisjunct(patternConfig),\n    Year: yearDisjunct(patternConfig),\n    YearRange: yearRangeDisjunct(patternConfig),\n    YearDeviation: yearDeviationDisjunct(patternConfig),\n    Text: textDisjunct(config, conjunct),\n    Distance: distanceDisjunct(patternConfig),\n    BoundingBox: boundingBoxDisjunct(patternConfig),\n    Literal: literalDisjunct,\n    NumericRange: numericRangeDisjunct(patternConfig),\n  });\n}\n\n/**\n * Extracts pattern configurations for the given relation from a search config\n * by looking into full relations list or ranges of categories.\n * @param config search configuration to look into\n * @param relation target relation to get patterns for\n * @param range relation range to use when looking into search categories\n */\nexport function tryGetRelationPatterns(\n  config: SemanticSearchConfig,\n  relation: Model.Relation,\n  range = relation.hasRange\n): PatternConfig[] {\n  if (_.has(config.relations, relation.iri.toString())) {\n    return config.relations[relation.iri.toString()];\n  } else if (_.has(config.categories, range.iri.toString())) {\n    return config.categories[range.iri.toString()];\n  } else {\n    return [];\n  }\n}\n\nfunction getMatchingPatternConfig(\n  config: SemanticSearchConfig,\n  projectionVariable: string,\n  conjunct: Model.Conjunct,\n  disjunct: Model.Disjunct\n): Resource | Set | Hierarchy | DateRange | NumericRange | Text | Literal | Place {\n  const range = conjunct.range;\n  return Model.matchConjunct<Resource | Set | Hierarchy | DateRange | NumericRange | Text | Literal | Place>({\n    Relation: (conj) => {\n      const relation = conj.relation;\n      const patterns = tryGetRelationPatterns(config, relation, range);\n      if (patterns.length === 0) {\n        if (Model.isSetDisjunct(disjunct)) {\n          const queryPattern = applySetPattern(DEFAULT_QUERY_PATTERN(projectionVariable), DEFAULT_SET_QUERY_PATTERN);\n          return {\n            kind: 'set',\n            queryPattern,\n          };\n        } else {\n          return {\n            kind: 'resource',\n            queryPattern: DEFAULT_QUERY_PATTERN(projectionVariable),\n          };\n        }\n      }\n\n      if (Model.isTemporalDisjunct(disjunct)) {\n        return _.find(patterns, (pattern) => pattern.kind === 'date-range') as DateRange;\n      } else if (Model.isSpatialDisjunct(disjunct)) {\n        return _.find(patterns, (pattern) => pattern.kind === 'place') as Place;\n      } else {\n        const hierarchyPattern = _.find(patterns, (pattern) => pattern.kind === 'hierarchy') as Hierarchy;\n        const resourcePattern = _.find(patterns, (pattern) => pattern.kind === 'resource') as Resource;\n        const setPattern = _.find(patterns, (pattern) => pattern.kind === 'set') as Set;\n        const literalPattern = _.find(patterns, (pattern) => pattern.kind === 'literal') as Literal;\n        const numericRangePattern = _.find(patterns, (pattern) => pattern.kind === 'numeric-range') as NumericRange;\n\n        if (Model.isSetDisjunct(disjunct)) {\n          if (hierarchyPattern) {\n            const queryPattern = applySetPattern(\n              hierarchyPattern.queryPattern,\n              setPattern ? setPattern.queryPattern : DEFAULT_SET_QUERY_PATTERN\n            );\n            return {\n              kind: 'set',\n              queryPattern,\n            };\n          } else if (resourcePattern) {\n            const queryPattern = applySetPattern(\n              resourcePattern.queryPattern,\n              setPattern ? setPattern.queryPattern : DEFAULT_SET_QUERY_PATTERN\n            );\n            return {\n              kind: 'set',\n              queryPattern,\n            };\n          } else {\n            const queryPattern = applySetPattern(DEFAULT_QUERY_PATTERN(projectionVariable), DEFAULT_SET_QUERY_PATTERN);\n            return {\n              kind: 'set',\n              queryPattern,\n            };\n          }\n        } else {\n          if (hierarchyPattern) {\n            return hierarchyPattern;\n          } else if (resourcePattern) {\n            return resourcePattern;\n          } else if (literalPattern) {\n            return literalPattern;\n          } else if (numericRangePattern) {\n            return numericRangePattern;\n          } else {\n            return {\n              kind: 'resource',\n              queryPattern: DEFAULT_QUERY_PATTERN(projectionVariable),\n            };\n          }\n        }\n      }\n    },\n    Text: () => getConfigPatternForCategory(config, range.iri) as Text,\n  })(conjunct);\n}\n\n/**\n * Because in blazegraph we disable re-ordering of statements\n * setPattern should be applied before relationPattern to\n * avoid huge join in big datasets\n */\nfunction applySetPattern(relationPattern: string, setPattern: string): string {\n  return setPattern + relationPattern;\n}\n\nfunction getGenericVariables(domain: Model.Category, conjunct: Model.Conjunct) {\n  return Model.matchConjunct({\n    Relation: (conj) => ({\n      [SEMANTIC_SEARCH_VARIABLES.DOMAIN_VAR]: domain.iri,\n      [SEMANTIC_SEARCH_VARIABLES.RANGE_VAR]: conj.range.iri,\n      [SEMANTIC_SEARCH_VARIABLES.RELATION_VAR]: conj.relation.iri,\n    }),\n    Text: () => ({ [SEMANTIC_SEARCH_VARIABLES.DOMAIN_VAR]: domain.iri }),\n  })(conjunct);\n}\n\nfunction parseQueryPattern(queryPattern: string, projectionVariable: string): SparqlJs.SelectQuery {\n  const query = SparqlUtil.parseQuerySync<SparqlJs.SelectQuery>(`SELECT * {{ ${queryPattern} }}`);\n  return rewriteProjectionVariable(query, projectionVariable);\n}\n\nclass Randomizer extends QueryVisitor {\n  private variablesMap: { [key: string]: string } = {};\n  private subjectVariable: string;\n  private rewriteSubjectVariable: SparqlJs.Term;\n\n  constructor(subjectVariable: string, rewriteSubjectVariable?: string) {\n    super();\n    this.subjectVariable = subjectVariable;\n    this.rewriteSubjectVariable = rewriteSubjectVariable as SparqlJs.Term;\n  }\n\n  variableTerm(variable: SparqlJs.Term): SparqlJs.Term {\n    if (variable === this.subjectVariable) {\n      return this.rewriteSubjectVariable ? this.rewriteSubjectVariable : variable;\n    }\n\n    if (!_.has(this.variablesMap, variable)) {\n      this.variablesMap[variable] = variable + '_' + uuid.v4().replace(/-/g, '_');\n    }\n    return this.variablesMap[variable] as SparqlJs.Term;\n  }\n}\n\nfunction randomizeVariables(\n  query: SparqlJs.SelectQuery,\n  subjectVariable: string,\n  rewriteSubjectVariable?: string\n): SparqlJs.SelectQuery {\n  new Randomizer(subjectVariable, rewriteSubjectVariable).query(query);\n  return query;\n}\n\nexport function disjunctToQueryPattern(\n  config: SemanticSearchConfig,\n  projectionVariable: string,\n  domain: Model.Category\n) {\n  return function (conjunct: Model.RelationConjunct) {\n    return function (disjunct: Model.Disjunct): SparqlJs.Pattern {\n      if (disjunct.kind === Model.EntityDisjunctKinds.Search) {\n        return complexDisjunctToQueryPattern(config, projectionVariable, domain, conjunct, disjunct);\n      }\n      if (disjunct.kind === Model.EntityDisjunctKinds.SavedSearch) {\n        return nestedQueryPattern(config, projectionVariable, domain, disjunct.value.query, conjunct, disjunct);\n      } else {\n        return simpleDisjunctToQueryPattern(config, projectionVariable, domain, conjunct, disjunct);\n      }\n    };\n  };\n}\n\nfunction complexDisjunctToQueryPattern(\n  config: SemanticSearchConfig,\n  projectionVariable: string,\n  domain: Model.Category,\n  conjunct: Model.RelationConjunct,\n  disjunct: Model.SearchDisjunct\n) {\n  const nestedQuery = generateSelectQueryPattern(projectionVariable, config, disjunct.value);\n  return nestedQueryPattern(config, projectionVariable, domain, nestedQuery, conjunct, disjunct);\n}\n\nfunction nestedQueryPattern(\n  config: SemanticSearchConfig,\n  projectionVariable: string,\n  domain: Model.Category,\n  nestedQuery: SparqlJs.SelectQuery,\n  conjunct: Model.RelationConjunct,\n  disjunct: Model.Disjunct\n) {\n  const patternQuery = simpleDisjunctPatternQuery(config, projectionVariable, domain, conjunct, disjunct);\n  const patterns = patternQuery.where;\n  patterns.unshift(\n    ...randomizeVariables(nestedQuery, projectionVariable, '?' + SEMANTIC_SEARCH_VARIABLES.RESOURCE_VAR).where\n  );\n  patternQuery.where = [{ type: 'group', patterns: patterns }];\n  return randomizeVariables(patternQuery, projectionVariable).where[0];\n}\n\nfunction simpleDisjunctToQueryPattern(\n  config: SemanticSearchConfig,\n  projectionVariable: string,\n  domain: Model.Category,\n  conjunct: Model.RelationConjunct,\n  disjunct: Model.Disjunct\n) {\n  const patternQuery = simpleDisjunctPatternQuery(config, projectionVariable, domain, conjunct, disjunct);\n  return randomizeVariables(patternQuery, projectionVariable).where[0];\n}\n\nfunction simpleDisjunctPatternQuery(\n  config: SemanticSearchConfig,\n  projectionVariable: string,\n  domain: Model.Category,\n  conjunct: Model.Conjunct,\n  disjunct: Model.Disjunct\n): SparqlJs.SelectQuery {\n  const patternConfig = getMatchingPatternConfig(config, projectionVariable, conjunct, disjunct);\n  let queryPattern: string;\n  if (patternConfig.kind === 'place') {\n    if (disjunct.kind === Model.SpatialDisjunctKinds.Distance) {\n      queryPattern = patternConfig.distanceQueryPattern;\n    } else if (disjunct.kind === Model.SpatialDisjunctKinds.BoundingBox) {\n      queryPattern = patternConfig.boundingBoxQueryPattern;\n    }\n  } else {\n    queryPattern = patternConfig.queryPattern;\n  }\n  const parsedPattern = parseQueryPattern(queryPattern, projectionVariable);\n  const parameters = _.assign(\n    getGenericVariables(domain, conjunct),\n    disjunctToVariables(config, patternConfig, conjunct)(disjunct)\n  );\n  return SparqlClient.setBindings(parsedPattern, parameters);\n}\n\nexport function conjunctToQueryPattern(\n  config: SemanticSearchConfig,\n  projectionVariable: string,\n  domain: Model.Category\n) {\n  return function (conjunct: Model.RelationConjunct): SparqlJs.Pattern {\n    const patterns = _.map(conjunct.disjuncts, disjunctToQueryPattern(config, projectionVariable, domain)(conjunct));\n    const flattenedPatterns = _.map(patterns, (pattern) => {\n      if (SparqlTypeGuards.isBlockPattern(pattern) && pattern.patterns.length === 1) {\n        return pattern.patterns[0];\n      } else {\n        return pattern;\n      }\n    });\n\n    if (flattenedPatterns.length === 1) {\n      return flattenedPatterns[0];\n    } else {\n      return {\n        type: 'union',\n        patterns: flattenedPatterns,\n      };\n    }\n  };\n}\n\nexport function conjunctsToQueryPatterns(\n  config: SemanticSearchConfig,\n  projectionVariable: string,\n  domain: Model.Category,\n  conjuncts: Array<Model.RelationConjunct>\n): Array<SparqlJs.Pattern> {\n  const patterns = _.map(conjuncts, conjunctToQueryPattern(config, projectionVariable, domain));\n  return _.flatten(\n    _.map(patterns, (pattern) => {\n      if (SparqlTypeGuards.isGroupPattern(pattern)) {\n        return pattern.patterns;\n      } else {\n        return pattern;\n      }\n    })\n  );\n}\n\nfunction generateSelectQueryPattern(\n  projectionVariable: string,\n  config: SemanticSearchConfig,\n  search: Model.Search\n): SparqlJs.SelectQuery {\n  const patterns = conjunctsToQueryPatterns(\n    config,\n    projectionVariable,\n    search.domain,\n    search.conjuncts as Array<Model.RelationConjunct>\n  );\n  return {\n    prefixes: {},\n    type: 'query',\n    queryType: 'SELECT',\n    variables: [projectionVariable as SparqlJs.Term],\n    where: patterns,\n  };\n}\n\n/**\n * In all configuration queries it is possible to refer to main result projection variable with ?subject alias, order to apply these queries to any base query\n * we need to properly re-write ?subject to actual projection variable from the base query\n */\nexport function rewriteProjectionVariable(\n  query: SparqlJs.SelectQuery,\n  projectionVariable: string\n): SparqlJs.SelectQuery {\n  const result = cloneQuery(query);\n  new (class extends QueryVisitor {\n    variableTerm(variable: SparqlJs.Term): SparqlJs.Term {\n      if (variable.substring(1) === SEMANTIC_SEARCH_VARIABLES.PROJECTION_ALIAS_VAR) {\n        return projectionVariable as SparqlJs.Term;\n      }\n    }\n  })().query(result);\n  return result;\n}\n\nexport function generateSelectQuery(\n  config: SemanticSearchConfig,\n  projectionVariableName: string,\n  search: Model.Search\n): SparqlJs.SelectQuery {\n  const projectionVariable = '?' + projectionVariableName;\n  const patterns = conjunctsToQueryPatterns(\n    config,\n    projectionVariable,\n    search.domain,\n    search.conjuncts as Array<Model.RelationConjunct>\n  );\n  return {\n    prefixes: {},\n    type: 'query',\n    queryType: 'SELECT',\n    distinct: true,\n    variables: [projectionVariable as SparqlJs.Term],\n    where: patterns,\n    limit: config.limit,\n  };\n}\n\nexport function blazegraphNoOptimizePattern(): SparqlJs.Pattern {\n  return {\n    type: 'bgp',\n    triples: [\n      {\n        subject: 'http://www.bigdata.com/queryHints#Query' as SparqlJs.Term,\n        predicate: 'http://www.bigdata.com/queryHints#optimizer' as SparqlJs.Term,\n        object: '\"None\"' as SparqlJs.Term,\n      },\n    ],\n  };\n}\n\n/**\n * Generates query for multidataset configuration.\n *\n * 1) In case of a federated setup, UNION group wrapped into the SERVICE call is generated for every dataset.\n * 2) In case of no federation, UNION group with dataset filter pattern is generated for every dataset.\n */\nexport function generateQueryForMultipleDatasets(\n  query: SparqlJs.SelectQuery | SparqlJs.AskQuery,\n  datasets: Array<Dataset> = [],\n  config?: DatasetsConfig\n): SparqlJs.SelectQuery | SparqlJs.AskQuery {\n  const federatedPatterns = generateFederatedQueryPatterns(query.where, datasets, config);\n  return {\n    ...query,\n    where: federatedPatterns,\n  };\n}\n\nexport function generateFederatedQueryPatterns(\n  patterns: Array<SparqlJs.Pattern>,\n  datasets: Array<Dataset>,\n  config?: DatasetsConfig\n): Array<SparqlJs.Pattern> {\n  const unionPatterns = datasets.map((dataset) => generatePatternForDataset(dataset, patterns, config));\n  if (unionPatterns.length > 1) {\n    return [\n      {\n        type: 'union',\n        patterns: _.clone(unionPatterns),\n      },\n    ];\n  } else if (unionPatterns.length === 1) {\n    return unionPatterns;\n  } else {\n    return patterns;\n  }\n}\n\nfunction generatePatternForDataset(\n  dataset: Dataset,\n  whereClause: Array<SparqlJs.Pattern>,\n  config?: DatasetsConfig\n): SparqlJs.Pattern {\n  const federated = config ? config.federated : false;\n  if (federated) {\n    if (dataset.iri === undefined && dataset.id === undefined) {\n      return {\n        type: 'group',\n        patterns: whereClause,\n      };\n    } else {\n      return wrapIntoService(whereClause, dataset.iri.value, dataset.silent);\n    }\n  } else {\n    return generateNonFederatedPatternForDataset(dataset, whereClause, config);\n  }\n}\n\n/**\n * Default dataset filter pattern that is used in non-federated mode for\n * multidataset queries.\n */\nconst DATASET_PATTERN = `\n  GRAPH ?__dataset__ {\n    ?subject a ?t .\n  }\n`;\n\nfunction generateNonFederatedPatternForDataset(\n  dataset: Dataset,\n  whereClause: Array<SparqlJs.Pattern>,\n  config?: DatasetsConfig\n): SparqlJs.Pattern {\n  const datasetPattern = Maybe.fromNullable(config)\n    .chain((c) => Maybe.fromNullable(c.datasetPattern))\n    .getOrElse(DATASET_PATTERN);\n  const patterns = SparqlUtil.parsePatterns(datasetPattern).concat(whereClause);\n  const parametrizedPatterns = SparqlClient.setBindings<SparqlJs.SelectQuery>(\n    {\n      prefixes: {},\n      type: 'query',\n      queryType: 'SELECT',\n      variables: ['*'],\n      where: patterns,\n    },\n    { __dataset__: dataset.iri }\n  ).where;\n  return {\n    type: 'group',\n    patterns: parametrizedPatterns,\n  };\n}\n\nfunction wrapIntoService(patterns: Array<SparqlJs.Pattern>, serviceUrl: string, silent = false): SparqlJs.Pattern {\n  return {\n    type: 'service',\n    name: serviceUrl as SparqlJs.Term,\n    silent: silent,\n    patterns: patterns,\n  };\n}\n"],"sourceRoot":""}