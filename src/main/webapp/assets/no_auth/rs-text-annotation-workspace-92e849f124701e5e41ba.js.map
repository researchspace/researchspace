{"version":3,"sources":["webpack:///./src/main/web/components/text-annotation/components/TextAnnotationWorkspace.tsx","webpack:///./src/main/web/components/text-annotation/model/AnnotationSchema.ts","webpack:///./src/main/web/components/text-annotation/model/ComponentModel.ts","webpack:///./src/main/web/components/text-annotation/model/EditorModel.ts","webpack:///./src/main/web/components/text-annotation/components/AnnotationEditForm.tsx","webpack:///./src/main/web/components/text-annotation/components/AnnotationSidebar.tsx","webpack:///./src/main/web/components/text-annotation/components/TextAnnotationEditor.tsx","webpack:///./src/main/web/components/text-annotation/model/TextSerialization.ts"],"names":["props","context","cancellation","Cancellation","persistingAnnotation","onEditorStateChange","newState","setState","editorState","onHighlightAnnotations","highlighted","highlightedAnnotations","onFocusAnnotation","focused","focusedAnnotation","onBeginAddingAnnotation","state","updateAnnotation","Schema","PLACEHOLDER_ANNOTATION","anno","iri","ANNOTATION_TO_DELETE","addAnnotation","deleteAnnotation","editedAnnotation","Set","value","showOrHideAnnotationEditorModal","onBeginEditingAnnotation","resetEditedAnnotation","onCancelEditingAnnotation","undefined","nextState","sameIri","add","onPersistAnnotation","initialAnnotationIri","bodyType","modelWithOnlyBody","cancelAll","source","Rdf","documentIri","nextAnnotationIri","subject","Kefir","constantError","Error","annotation","annotations","find","equals","selector","selectedText","targetModel","type","createRangeTarget","createPointTarget","createdByEvent","createProvenanceEvent","userIri","permissions","modifiedAt","getCurrentDateTime","annotationModel","addField","OAHasTarget","CrmdigL48iWasAnnotationCreatedBy","map","getPersistence","persist","Forms","FieldValue","empty","renderVersion","mapErrors","error","addNotification","level","message","onDeleteAnnotation","constant","currentModel","definitions","Immutable","Map","fields","errors","FieldError","noErrors","task","observe","handlers","highlightAnnotations","focusAnnotation","beginAddingAnnotation","beginEditingAnnotation","cancelEditingAnnotation","persistAnnotation","loadingDocument","getFileManager","repository","FileManager","componentDidMount","this","annotationTooltip","annotationTypes","extractAnnotationTypes","children","types","React","Children","forEach","child","extractAnnotationType","set","container","typesMetadata","combine","document","fetchDocument","fetchAnnotations","semanticContext","has","VocabPlatform","FormContainer","fromPromise","getUser","userInfo","userURI","flatMapErrors","formCreate","isPermitted","formUpdate","formDelete","ldpCreate","Permissions","toLdp","ldpUpdateAny","ldpUpdateOwner","ldpDeleteAny","ldpDeleteOwner","p","create","updateOwner","updateAny","deleteOwner","deleteAny","toProperty","makeIntitialEditorState","sourceHtml","loadingError","getFileResource","flatMap","resource","fileUrl","getFileUrl","fileName","storage","requestAsProperty","http","get","accept","response","text","componentWillUnmount","render","Spinner","spinnerDelay","ErrorNotification","title","errorMessage","className","styles","component","TextAnnotationEditor","editorPanel","tooltipTemplate","AnnotationSidebar","annotationsPanel","fallbackTemplate","getOverlaySystem","show","OverlayDialog","onHide","AnnotationEditForm","subjectTemplate","annotationSubjectTemplate","annotationBodyType","hide","LdpPersistence","defaultProps","Component","TextAnnotationWorkspace","JSONLD_ANNOTATION_CONTEXT","oa","rdf","xsd","createDirectField","predicate","normalizeFieldDefinition","selectPattern","SparqlUtil","serializeQuery","SparqlClient","setBindings","parseQuery","insertPattern","deletePattern","makeSelector","ownerIri","xpath","offset","rdfOffset","valueFromRdf","literal","toString","nonNegativeInteger","makeComposite","def","RdfType","XPathSelector","RdfValue","OARefinedBy","TextPositionSelector","OAStart","OAEnd","composite","CompositeValue","id","values","List","Array","isArray","generateSubjectByTemplate","fromLabeled","hasTarget","minOccurs","maxOccurs","xsdDatatype","anyURI","OAHasBody","hasBody","OAHasSelector","hasSelector","OAHasSource","hasSource","OAHasStartSelector","hasStartSelector","OAHasEndSelector","hasEndSelector","refinedBy","start","end","crmdig","L48i_was_annotation_created_by","CrmP4HasTimeSpan","dateTime","CrmP14CarriedOutBy","crm","P14_carried_out_by","params","SpecificResource","RangeSelector","xPath","D30_Annotation_Event","moment","utc","format","base","ANNOATIONS_QUERY","selectType","query","__documentIri__","select","iris","results","bindings","isIri","push","length","zip","fetchAnnotation","documentLoader","JsonLd","makeDocumentLoader","overrideContexts","LdpService","getResourceRequest","ttl","fromRdf","useNativeTypes","doc","frame","ANNOTATION_FRAME","framed","target","body","extractPointSelector","startSelector","endSelector","author","carriedOutBy","Number","a","b","mapIriToColor","hash","Math","abs","hashFnv32a","str","seed","i","l","hval","charCodeAt","floor","pow","TextAnnotationTemplateBindings","getAccentColor","opacity","baseColor","color","parsed","rgb","compute","sameAuthor","allowEdit","allowDelete","iconUrl","AnnotationData","NodeData","getPointFromNodeOffset","node","nodeKeyToPath","lastText","getTexts","nodes","Slate","Point","key","path","addMarksAtRange","range","markType","markData","getTextsAtRange","reduce","acc","isInNode","startOffset","endOffset","addMark","Mark","data","moveToEndOfNode","insertInlineAtPoint","point","inlineType","inlineData","changed","splitNode","splitPoint","incrementLastPathIndex","index","size","insertNode","Inline","findAnnotationLevels","walkNode","object","getLeaves","walkLeaf","ANNOTATION_POINT_TYPE","walkNodes","leaf","occupiedLevels","marks","mark","ANNOTATION_RANGE_TYPE","findUnoccupiedLevel","occupied","mapAnnotations","mapper","mapLeaf","updated","mappedData","removeMark","updateMark","mapNode","mappedLeaves","setLeaves","mappedNodes","filter","asProps","toObject","change","assignXPaths","assingXPathToNodes","parentPath","makeStep","makeChildIndexTracker","nodeType","next","assingXPathToNode","nodePath","resultNodes","Document","mergeInAnnotations","findNodeXPaths","xpathToNode","xpathOrder","getKeysToPathsTable","annotatedDoc","getRangeFromSelector","startNode","endNode","Range","focus","anchor","console","warn","sortBy","updateAnnotationLevels","levels","annotationIris","isTarget","Boolean","annotationIri","createDecorationsForRange","Decoration","moveToStartOfNode","normalize","getPath","setValueProps","selection","decorations","Value","sortAnnotationsByFirstOccurence","order","result","sort","j","extractTextFragment","getFragmentAtRange","getBlocks","join","formKey","selectedBodyType","componentWillReceiveProps","nextProps","metadata","ResourceEditorForm","FIELDS","newSubjectTemplate","postAction","persistence","intialModel","isEmpty","remove","formContent","selectedFragment","selectedFragmentText","renderBodyTypeSelector","HiddenInput","for","defaultValues","Annotation","D29_Annotation_Object","bodyInput","cloneElement","input","renderHeader","name","cancelButton","onClick","options","label","optionRenderer","option","bodyTypeIcon","src","clearable","placeholder","valueRenderer","onChange","newValue","onAnnotationListMount","annotationList","onSelectTab","tabKey","selectedTab","onClickInsideAnnotation","e","HTMLButtonElement","getAttribute","componentDidUpdate","prevProps","scrollAnnotationIntoView","classnames","Tab","Container","activeKey","onSelect","Nav","bsStyle","NavItem","eventKey","from","count","countAnnotationForTab","disabled","tabHeader","tabIcon","ref","renderAnnotation","hidden","isPlaceholder","bodyTypeMetadata","style","display","newAnnotationPlaceholder","TemplateScopeProvider","markupTemplateScope","templateScope","TemplateItem","template","defaultTemplate","listBounds","getBoundingClientRect","elements","element","elementBounds","elementTop","top","listScrollTop","scrollTop","listScrollBottom","height","only","EMPTY_SET","debounceTooltip","onSidelineMount","sideline","onKeyDown","event","editor","keyboarEvent","ctrlKey","metaKey","keyCode","preventDefault","onTextClick","ignoreIfReadonly","onEditorMount","renderNode","attributes","BLOCK_TAGS","INLINE_TAGS","createElement","AnnotationInline","TAG_NAME","inline","getAnnotationType","onClickAnnotation","onStartHovering","onStartHoveringAnnotation","onStopHovering","onStopHoveringAnnotation","renderMark","MARK_TAGS","AnnotationMark","markedSelection","later","updateSelectionOffset","onAddAnnotationClick","selectionTopOffset","hoverState","hovered","highlightedDoc","EditorModel","EditorState","tooltip","unhighlightedDoc","previousState","hovering","onTooltipHide","onTooltipClick","owner","textEditor","Editor","spellCheck","onDragStart","onCut","onPaste","addAnnotationSideline","Button","addAnnotationButton","addAnnotationIcon","renderTooltip","position","left","TargetedPopover","hideTimeout","targetLeft","targetTop","popoverSide","arrowAlignment","componentProps","rect","findDOMRange","override","baseProps","nextDocument","isExpanded","findXPathAt","parentNode","getAncestors","last","SLATE_HTML","deserialize","stopPropagation","onMouseEnter","currentTarget","right","toArray","onMouseLeave","paddingBottom","borderBottom","borderColor","backgroundColor","pointAnnotation","blockquote","div","h1","h2","h3","h4","h5","h6","pre","section","table","tbody","td","th","thead","tr","span","code","em","strong","u","SLATE_RULES","el","Node","TEXT_NODE","textContent","match","tagName","toLowerCase","getAttributesAsReactProps","childNodes","serialize","obj","attr","item","parsedPropValue","ModuleRegistry","parseReactStyleFromCss","rules"],"mappings":"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","file":"rs-text-annotation-workspace-92e849f124701e5e41ba.js","sourcesContent":["/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\nimport * as React from 'react';\n\nimport { Cancellation, requestAsProperty } from 'platform/api/async';\nimport { Component } from 'platform/api/components';\nimport * as http from 'platform/api/http';\nimport { Rdf } from 'platform/api/rdf';\nimport { VocabPlatform } from 'platform/api/rdf/vocabularies';\n\nimport { FileManager } from 'platform/api/services/file-manager';\nimport { Util as SecurityUtil, Permissions } from 'platform/api/services/security';\n\nimport * as Forms from 'platform/components/forms';\nimport { ErrorNotification, addNotification } from 'platform/components/ui/notification';\nimport { OverlayDialog, getOverlaySystem } from 'platform/components/ui/overlay';\nimport { Spinner } from 'platform/components/ui/spinner';\n\nimport * as Schema from '../model/AnnotationSchema';\nimport { TextEditorState, WorkspaceHandlers, AnnotationBodyType, WorkspacePermissions } from '../model/ComponentModel';\n\nimport { AnnotationEditForm } from './AnnotationEditForm';\nimport { AnnotationSidebar } from './AnnotationSidebar';\nimport { TextAnnotationEditor, makeIntitialEditorState } from './TextAnnotationEditor';\nimport { extractAnnotationType } from './TextAnnotationType';\n\nimport * as styles from './TextAnnotationWorkspace.scss';\n\nexport interface TextAnnotationWorkspaceProps {\n  /**\n   * Text document IRI to load in the annotation editor.\n   * All annotations attached to this document are loaded as well.\n   */\n  documentIri: string;\n  /**\n   * ID of the <semantic-link iri='http://help.researchspace.org/resource/Storage'>\n   * storage</semantic-link> to load text document content.\n   */\n  storage: string;\n  /**\n   * IRI template for generating annotation IRIs. See <code>new-subject-template</code>\n   * attribute at\n   * <semantic-link iri='http://help.researchspace.org/resource/SemanticForm'></semantic-link>\n   * for syntax.\n   */\n  annotationSubjectTemplate: string;\n  /**\n   * Tooltip template to render when hovered over annotation in the editor.\n   *\n   * See `AnnotationTemplateBindings` for template bindings.\n   */\n  annotationTooltip: string;\n  /**\n   * Fallback template to render annotations with unknown type in the sidebar.\n   *\n   * See `AnnotationTemplateBindings` for template bindings.\n   */\n  fallbackTemplate?: string;\n}\n\ninterface State {\n  annotationTypes?: ReadonlyMap<string, AnnotationBodyType>;\n  loadingDocument?: boolean;\n  loadingError?: any;\n  permissions?: WorkspacePermissions;\n  editorState?: TextEditorState;\n  highlightedAnnotations?: ReadonlySet<string>;\n  focusedAnnotation?: Rdf.Iri;\n  editedAnnotation?: Rdf.Iri;\n}\n\nexport class TextAnnotationWorkspace extends Component<TextAnnotationWorkspaceProps, State> {\n  static readonly defaultProps: Partial<TextAnnotationWorkspaceProps> = {\n    fallbackTemplate: '<div>Unknown type for annotation: {{iri.value}}</div>',\n  };\n\n  private readonly cancellation = new Cancellation();\n  private persistingAnnotation = new Cancellation();\n\n  private handlers: WorkspaceHandlers;\n\n  constructor(props: TextAnnotationWorkspaceProps, context: any) {\n    super(props, context);\n    this.handlers = {\n      highlightAnnotations: this.onHighlightAnnotations,\n      focusAnnotation: this.onFocusAnnotation,\n      beginAddingAnnotation: this.onBeginAddingAnnotation,\n      beginEditingAnnotation: this.onBeginEditingAnnotation,\n      cancelEditingAnnotation: this.onCancelEditingAnnotation,\n      persistAnnotation: this.onPersistAnnotation,\n      deleteAnnotation: this.onDeleteAnnotation,\n    };\n    this.state = {\n      loadingDocument: true,\n      highlightedAnnotations: new Set<string>(),\n    };\n  }\n\n  private getFileManager() {\n    const { repository } = this.context.semanticContext;\n    return new FileManager({ repository });\n  }\n\n  componentDidMount() {\n    if (typeof this.props.annotationTooltip !== 'string') {\n      throw new Error(`Missing required property 'annotation-tooltip'`);\n    }\n\n    const annotationTypes = extractAnnotationTypes(this.props.children);\n    this.setState({ annotationTypes });\n\n    const documentIri = Rdf.iri(this.props.documentIri);\n\n    this.cancellation\n      .map(\n        Kefir.combine({\n          document: this.fetchDocument(documentIri),\n          annotations: Schema.fetchAnnotations(\n            documentIri,\n            this.context.semanticContext,\n            makeTypeSelector(annotationTypes)\n          ),\n          permissions: fetchPermissions({ container: VocabPlatform.FormContainer }),\n        })\n      )\n      .observe({\n        value: ({ document, annotations, permissions }) => {\n          this.setState({\n            loadingDocument: false,\n            permissions,\n            editorState: makeIntitialEditorState({ sourceHtml: document, annotations }),\n          });\n        },\n        error: (loadingError) => this.setState({ loadingDocument: false, loadingError }),\n      });\n  }\n\n  private fetchDocument(documentIri: Rdf.Iri): Kefir.Property<string> {\n    return this.getFileManager()\n      .getFileResource(documentIri)\n      .flatMap((resource) => {\n        const fileUrl = FileManager.getFileUrl(resource.fileName, this.props.storage);\n        return requestAsProperty(http.get(fileUrl).accept('text/html'));\n      })\n      .map((response) => response.text)\n      .toProperty();\n  }\n\n  componentWillUnmount() {\n    this.cancellation.cancelAll();\n    this.persistingAnnotation.cancelAll();\n  }\n\n  render() {\n    const documentIri = Rdf.iri(this.props.documentIri);\n    const { annotationTypes, loadingDocument, loadingError } = this.state;\n    if (!annotationTypes || loadingDocument) {\n      return <Spinner spinnerDelay={0} />;\n    } else if (loadingError) {\n      return <ErrorNotification title={`Error loading document ${documentIri}`} errorMessage={loadingError} />;\n    }\n\n    const { permissions, editorState, highlightedAnnotations, focusedAnnotation } = this.state;\n    return (\n      <div className={styles.component}>\n        <TextAnnotationEditor\n          className={styles.editorPanel}\n          editorState={editorState}\n          onEditorStateChange={this.onEditorStateChange}\n          annotationTypes={annotationTypes}\n          tooltipTemplate={this.props.annotationTooltip}\n          permissions={permissions}\n          handlers={this.handlers}\n        />\n        <AnnotationSidebar\n          className={styles.annotationsPanel}\n          annotationTypes={annotationTypes}\n          fallbackTemplate={this.props.fallbackTemplate}\n          annotations={editorState.annotations}\n          highlightedAnnotations={highlightedAnnotations}\n          focusedAnnotation={focusedAnnotation}\n          permissions={permissions}\n          handlers={this.handlers}\n        />\n      </div>\n    );\n  }\n\n  private onEditorStateChange = (newState: TextEditorState) => {\n    this.setState({ editorState: newState });\n  };\n\n  private onHighlightAnnotations = (highlighted: ReadonlySet<string>) => {\n    this.setState({ highlightedAnnotations: highlighted });\n  };\n\n  private onFocusAnnotation = (focused: Rdf.Iri | undefined) => {\n    this.setState({ focusedAnnotation: focused });\n  };\n\n  private onBeginAddingAnnotation = () => {\n    this.setState(\n      (state): State => {\n        // delete placeholder annotation only after adding a new one to keep\n        // the same document structure for selection target\n        const nextState = this.state.editorState\n          .updateAnnotation(Schema.PLACEHOLDER_ANNOTATION, (anno) => {\n            return { ...anno, iri: Schema.ANNOTATION_TO_DELETE };\n          })\n          .addAnnotation(Schema.PLACEHOLDER_ANNOTATION)\n          .deleteAnnotation(Schema.ANNOTATION_TO_DELETE);\n        return {\n          editorState: nextState,\n          editedAnnotation: Schema.PLACEHOLDER_ANNOTATION,\n          focusedAnnotation: Schema.PLACEHOLDER_ANNOTATION,\n          highlightedAnnotations: new Set([Schema.PLACEHOLDER_ANNOTATION.value]),\n        };\n      },\n      () => {\n        this.showOrHideAnnotationEditorModal();\n      }\n    );\n  };\n\n  private onBeginEditingAnnotation = (iri: Rdf.Iri) => {\n    this.resetEditedAnnotation(iri);\n  };\n\n  private onCancelEditingAnnotation = () => {\n    if (this.state.editedAnnotation) {\n      this.resetEditedAnnotation(undefined);\n    }\n  };\n\n  private resetEditedAnnotation = (iri: Rdf.Iri | undefined) => {\n    this.setState(\n      (state): State => {\n        const { editorState, editedAnnotation } = state;\n        const nextState = Schema.sameIri(editedAnnotation, Schema.PLACEHOLDER_ANNOTATION)\n          ? editorState.deleteAnnotation(Schema.PLACEHOLDER_ANNOTATION)\n          : editorState;\n        const highlightedAnnotations = new Set<string>();\n        if (iri) {\n          highlightedAnnotations.add(iri.value);\n        }\n        return {\n          editorState: nextState,\n          editedAnnotation: iri,\n          focusedAnnotation: iri,\n          highlightedAnnotations,\n        };\n      },\n      () => {\n        this.showOrHideAnnotationEditorModal();\n      }\n    );\n  };\n\n  private showOrHideAnnotationEditorModal() {\n    const { editedAnnotation } = this.state;\n    if (editedAnnotation) {\n      const annotation = this.state.editorState.annotations.find((anno) => Schema.sameIri(anno.iri, editedAnnotation));\n      getOverlaySystem().show(\n        'rs-text-annotation-workspace',\n        <OverlayDialog\n          show={true}\n          title={editedAnnotation.equals(Schema.PLACEHOLDER_ANNOTATION) ? 'New annotation' : 'Edit annotation'}\n          onHide={this.handlers.cancelEditingAnnotation}\n        >\n          <AnnotationEditForm\n            subject={editedAnnotation}\n            subjectTemplate={this.props.annotationSubjectTemplate}\n            selectedText={annotation ? annotation.selectedText : undefined}\n            annotationBodyType={annotation ? annotation.bodyType : undefined}\n            annotationTypes={this.state.annotationTypes}\n            handlers={this.handlers}\n          />\n        </OverlayDialog>\n      );\n    } else {\n      getOverlaySystem().hide('rs-text-annotation-workspace');\n    }\n  }\n\n  private onPersistAnnotation = (\n    initialAnnotationIri: Rdf.Iri,\n    bodyType: Rdf.Iri,\n    modelWithOnlyBody: Forms.CompositeValue\n  ): Kefir.Property<void> => {\n    this.persistingAnnotation.cancelAll();\n    this.persistingAnnotation = new Cancellation();\n\n    const source = Rdf.iri(this.props.documentIri);\n\n    const nextAnnotationIri = modelWithOnlyBody.subject;\n    if (!initialAnnotationIri) {\n      return Kefir.constantError<any>(new Error('Failed to find annotation to persist'));\n    }\n\n    const annotation = this.state.editorState.annotations.find((anno) => anno.iri.equals(initialAnnotationIri));\n    const { selector, selectedText } = annotation;\n\n    const targetModel =\n      selector.type === 'range'\n        ? Schema.createRangeTarget({ source, selector, selectedText })\n        : Schema.createPointTarget({ source, selector });\n\n    const createdByEvent = Schema.createProvenanceEvent({\n      source,\n      userIri: this.state.permissions.userIri,\n      modifiedAt: Schema.getCurrentDateTime(),\n    });\n\n    let annotationModel = modelWithOnlyBody;\n    annotationModel = Schema.addField(annotationModel, Schema.OAHasTarget, [targetModel]);\n    annotationModel = Schema.addField(annotationModel, Schema.CrmdigL48iWasAnnotationCreatedBy, [createdByEvent]);\n\n    return this.persistingAnnotation\n      .map(this.getPersistence().persist(Forms.FieldValue.empty, annotationModel))\n      .map(() => {\n        this.setState(\n          (state): State => {\n            const nextState = state.editorState.updateAnnotation(initialAnnotationIri, (anno) => ({\n              ...anno,\n              iri: nextAnnotationIri,\n              bodyType,\n              // update annotation version to re-render template in sidebar\n              renderVersion: (anno.renderVersion || 0) + 1,\n            }));\n            return {\n              editorState: nextState,\n              editedAnnotation: Schema.sameIri(state.editedAnnotation, initialAnnotationIri)\n                ? undefined\n                : state.editedAnnotation,\n              highlightedAnnotations: new Set<string>(),\n            };\n          },\n          () => {\n            this.showOrHideAnnotationEditorModal();\n          }\n        );\n      })\n      .mapErrors<void>((error) => {\n        addNotification(\n          {\n            level: 'error',\n            message: 'Failed to create annotation',\n          },\n          error\n        );\n        return error;\n      });\n  };\n\n  private onDeleteAnnotation = (iri: Rdf.Iri): Kefir.Property<void> => {\n    if (!this.state.editorState.annotations.find((annotation) => annotation.iri.equals(iri))) {\n      // annotation is not created yet\n      return Kefir.constant(undefined);\n    }\n    const currentModel: Forms.CompositeValue = {\n      type: 'composite',\n      subject: iri,\n      definitions: Immutable.Map(),\n      fields: Immutable.Map(),\n      errors: Forms.FieldError.noErrors,\n    };\n\n    const task = this.getPersistence()\n      .persist(currentModel, Forms.FieldValue.empty)\n      .map(() => {\n        const nextState = this.state.editorState.deleteAnnotation(iri);\n        this.setState({ editorState: nextState });\n      });\n    task.observe({\n      error: (error) => {\n        addNotification(\n          {\n            level: 'error',\n            message: 'Failed to delete annotation',\n          },\n          error\n        );\n      },\n    });\n    return task;\n  };\n\n  private getPersistence() {\n    const { semanticContext } = this.context;\n    return new Forms.LdpPersistence({\n      type: 'ldp',\n      repository: semanticContext.repository,\n    });\n  }\n}\n\nfunction extractAnnotationTypes(children: React.ReactNode): ReadonlyMap<string, AnnotationBodyType> {\n  const types = new Map<string, AnnotationBodyType>();\n  React.Children.forEach(children, (child) => {\n    const type = extractAnnotationType(child);\n    types.set(type.iri.value, type);\n  });\n  return types;\n}\n\nfunction makeTypeSelector(\n  typesMetadata: ReadonlyMap<string, AnnotationBodyType>\n): (types: ReadonlyArray<Rdf.Iri>) => Rdf.Iri | undefined {\n  return (types) => {\n    for (const type of types) {\n      if (typesMetadata.has(type.value)) {\n        return type;\n      }\n    }\n    return undefined;\n  };\n}\n\nfunction fetchPermissions({ container = VocabPlatform.FormContainer }): Kefir.Property<WorkspacePermissions> {\n  return Kefir.combine(\n    {\n      userIri: Kefir.fromPromise(SecurityUtil.getUser())\n        .map((userInfo) => Rdf.iri(userInfo.userURI))\n        .flatMapErrors<Rdf.Iri | undefined>(() => Kefir.constant(undefined)),\n      formCreate: SecurityUtil.isPermitted('forms:ldp:create'),\n      formUpdate: SecurityUtil.isPermitted('forms:ldp:update'),\n      formDelete: SecurityUtil.isPermitted('forms:ldp:delete'),\n      ldpCreate: SecurityUtil.isPermitted(Permissions.toLdp('container', container, 'create', 'any')),\n      ldpUpdateAny: SecurityUtil.isPermitted(Permissions.toLdp('container', container, 'update', 'any')),\n      ldpUpdateOwner: SecurityUtil.isPermitted(Permissions.toLdp('container', container, 'update', 'owner')),\n      ldpDeleteAny: SecurityUtil.isPermitted(Permissions.toLdp('container', container, 'delete', 'any')),\n      ldpDeleteOwner: SecurityUtil.isPermitted(Permissions.toLdp('container', container, 'delete', 'owner')),\n    },\n    (p): WorkspacePermissions => ({\n      userIri: p.userIri,\n      create: p.formCreate && p.ldpCreate,\n      updateOwner: p.formUpdate && p.ldpUpdateOwner,\n      updateAny: p.formUpdate && p.ldpUpdateAny,\n      deleteOwner: p.formDelete && p.ldpDeleteOwner,\n      deleteAny: p.formDelete && p.ldpDeleteAny,\n    })\n  ).toProperty();\n}\n\nexport default TextAnnotationWorkspace;\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport * as Kefir from 'kefir';\nimport * as moment from 'moment';\n\nimport { Rdf, vocabularies } from 'platform/api/rdf';\nimport * as JsonLd from 'platform/api/rdf/formats/JsonLd';\nimport { SparqlClient, SparqlUtil } from 'platform/api/sparql';\n\nimport { LdpService } from 'platform/api/services/ldp';\n\nimport * as Forms from 'platform/components/forms';\n\nimport { crm, crmdig } from 'platform/data/vocabularies';\n\nconst JSONLD_ANNOTATION_CONTEXT = require('./annotation-context.json');\n\nconst { oa, rdf, xsd, VocabPlatform } = vocabularies;\n\nexport const OAHasTarget = createDirectField(oa.hasTarget, {\n  id: 'oaHasTarget',\n  minOccurs: 1,\n  maxOccurs: 1,\n  xsdDatatype: xsd.anyURI,\n});\n\nexport const OAHasBody = createDirectField(oa.hasBody, {\n  id: 'oaHasBody',\n  minOccurs: 1,\n  maxOccurs: 1,\n  xsdDatatype: xsd.anyURI,\n});\n\nexport const OAHasSelector = createDirectField(oa.hasSelector, {\n  id: 'oaHasSelector',\n  minOccurs: 1,\n  maxOccurs: 1,\n  xsdDatatype: xsd.anyURI,\n});\n\nexport const OAHasSource = createDirectField(oa.hasSource, {\n  id: 'oaHasSource',\n  minOccurs: 1,\n  maxOccurs: 1,\n  xsdDatatype: xsd.anyURI,\n});\n\nexport const OAHasStartSelector = createDirectField(oa.hasStartSelector, {\n  id: 'oaHasStartSelector',\n  minOccurs: 1,\n  maxOccurs: 1,\n  xsdDatatype: xsd.anyURI,\n});\n\nexport const OAHasEndSelector = createDirectField(oa.hasEndSelector, {\n  id: 'oaHasEndSelector',\n  minOccurs: 1,\n  maxOccurs: 1,\n  xsdDatatype: xsd.anyURI,\n});\n\nexport const OARefinedBy = createDirectField(oa.refinedBy, {\n  id: 'oaRefinedBy',\n  minOccurs: 1,\n  maxOccurs: 1,\n  xsdDatatype: xsd.anyURI,\n});\n\nexport const OAStart = createDirectField(oa.start, {\n  id: 'oaStart',\n  minOccurs: 1,\n  maxOccurs: 1,\n  xsdDatatype: xsd.nonNegativeInteger,\n});\n\nexport const OAEnd = createDirectField(oa.end, {\n  id: 'oaEnd',\n  minOccurs: 1,\n  maxOccurs: 1,\n  xsdDatatype: xsd.nonNegativeInteger,\n});\n\nexport const RdfType = createDirectField(rdf.type, { id: 'type', xsdDatatype: xsd.anyURI });\n\nexport const RdfValue = createDirectField(rdf.value, { id: 'value' });\n\nexport const CrmdigL48iWasAnnotationCreatedBy = createDirectField(crmdig.L48i_was_annotation_created_by, {\n  id: 'createdBy',\n});\n\nexport const CrmP4HasTimeSpan = Forms.normalizeFieldDefinition({\n  id: 'modifiedAt',\n  xsdDatatype: xsd.dateTime,\n  selectPattern: `\n    PREFIX crm: <http://www.cidoc-crm.org/cidoc-crm/>\n    SELECT $value WHERE {\n      $subject crm:P4_has_time_span ?span.\n      ?span crm:P81a_end_of_the_begin $value.\n    }\n  `,\n  insertPattern: `\n    PREFIX crm: <http://www.cidoc-crm.org/cidoc-crm/>\n    INSERT {\n      $subject crm:P4_has_time_span ?span.\n      ?span crm:P81a_end_of_the_begin $value.\n      ?span crm:P81b_begin_of_the_end $value.\n    } WHERE {\n      BIND(IRI(CONCAT(STR($subject), \"/modifiedAt\")) as ?span)\n    }\n  `,\n  deletePattern: `\n    PREFIX crm: <http://www.cidoc-crm.org/cidoc-crm/>\n    DELETE {\n      $subject crm:P4_has_time_span ?span.\n      ?span crm:P81a_end_of_the_begin $value.\n      ?span crm:P81b_begin_of_the_end $value.\n    } WHERE {\n      $subject crm:P4_has_time_span ?span.\n      ?span crm:P81a_end_of_the_begin $value.\n    }\n  `,\n});\n\nexport const CrmP14CarriedOutBy = createDirectField(crm.P14_carried_out_by, { id: 'author', xsdDatatype: xsd.anyURI });\n\nfunction createDirectField(predicate: Rdf.Iri, props: Forms.FieldDefinitionProp) {\n  return Forms.normalizeFieldDefinition({\n    ...props,\n    selectPattern: SparqlUtil.serializeQuery(\n      SparqlClient.setBindings(SparqlUtil.parseQuery(`SELECT $value WHERE { $subject ?predicate $value }`), {\n        predicate,\n      })\n    ),\n    insertPattern: SparqlUtil.serializeQuery(\n      SparqlClient.setBindings(SparqlUtil.parseQuery(`INSERT { $subject ?predicate $value } WHERE {}`), { predicate })\n    ),\n    deletePattern: SparqlUtil.serializeQuery(\n      SparqlClient.setBindings(SparqlUtil.parseQuery(`DELETE { $subject ?predicate $value } WHERE {}`), { predicate })\n    ),\n  });\n}\n\nexport type AnnotationSelector = RangeSelector | PointSelector;\n\nexport interface RangeSelector {\n  readonly type: 'range';\n  readonly start: PointSelector;\n  readonly end: PointSelector;\n}\n\nexport interface PointSelector {\n  readonly type: 'point';\n  readonly xPath: string;\n  readonly offset: number;\n}\n\nexport function createRangeTarget(params: {\n  source: Rdf.Iri;\n  selector: RangeSelector;\n  selectedText?: string;\n}): Forms.CompositeValue {\n  const { source, selector, selectedText } = params;\n  return makeComposite(params.source, `range-source-{{UUID}}`, [\n    { def: RdfType, value: valueFromRdf(oa.SpecificResource) },\n    { def: OAHasSource, value: valueFromRdf(source) },\n    {\n      def: RdfValue,\n      value: typeof selectedText === 'string' ? valueFromRdf(Rdf.literal(selectedText)) : [],\n    },\n    {\n      def: OAHasSelector,\n      value: makeComposite(params.source, `range-{{UUID}}`, [\n        { def: RdfType, value: valueFromRdf(oa.RangeSelector) },\n        {\n          def: OAHasStartSelector,\n          value: makeSelector(params.source, selector.start.xPath, selector.start.offset),\n        },\n        {\n          def: OAHasEndSelector,\n          value: makeSelector(params.source, selector.end.xPath, selector.end.offset),\n        },\n      ]),\n    },\n  ]);\n}\n\nexport function createPointTarget(params: { source: Rdf.Iri; selector: PointSelector }): Forms.CompositeValue {\n  const { source, selector } = params;\n  return makeComposite(params.source, `point-source-{{UUID}}`, [\n    { def: OAHasSource, value: valueFromRdf(source) },\n    {\n      def: OAHasSelector,\n      value: makeSelector(params.source, selector.xPath, selector.offset),\n    },\n  ]);\n}\n\nexport function createProvenanceEvent(params: {\n  source: Rdf.Iri;\n  userIri: Rdf.Iri;\n  modifiedAt: Rdf.Literal;\n}): Forms.CompositeValue {\n  return makeComposite(params.source, 'annotation-event-{{UUID}}', [\n    { def: RdfType, value: valueFromRdf(crmdig.D30_Annotation_Event) },\n    { def: CrmP4HasTimeSpan, value: valueFromRdf(params.modifiedAt) },\n    { def: CrmP14CarriedOutBy, value: valueFromRdf(params.userIri) },\n  ]);\n}\n\nexport function getCurrentDateTime(): Rdf.Literal {\n  return Rdf.literal(moment.utc().format(), xsd.dateTime);\n}\n\nfunction makeSelector(ownerIri: Rdf.Iri, xpath: string, offset: number) {\n  const rdfOffset = valueFromRdf(Rdf.literal(offset.toString(), xsd.nonNegativeInteger));\n  return makeComposite(ownerIri, `xpath-{{UUID}}`, [\n    { def: RdfType, value: valueFromRdf(oa.XPathSelector) },\n    { def: RdfValue, value: valueFromRdf(Rdf.literal(xpath)) },\n    {\n      def: OARefinedBy,\n      value: makeComposite(ownerIri, `offset-{{UUID}}`, [\n        { def: RdfType, value: valueFromRdf(oa.TextPositionSelector) },\n        { def: OAStart, value: rdfOffset },\n        { def: OAEnd, value: rdfOffset },\n      ]),\n    },\n  ]);\n}\n\nfunction makeComposite(\n  ownerIri: Rdf.Iri,\n  subjectTemplate: string,\n  fields: ReadonlyArray<{\n    def: Forms.FieldDefinition;\n    value: Forms.FieldValue | ReadonlyArray<Forms.FieldValue>;\n  }>\n): Forms.CompositeValue {\n  const composite: Forms.CompositeValue = {\n    type: Forms.CompositeValue.type,\n    definitions: Immutable.Map(fields.map((p) => [p.def.id, p.def] as [string, Forms.FieldDefinition])),\n    subject: Rdf.iri(''),\n    fields: Immutable.Map(\n      fields.map((p) => {\n        const values = Immutable.List(Array.isArray(p.value) ? p.value : [p.value]);\n        const state: Forms.FieldState = { values, errors: Forms.FieldError.noErrors };\n        return [p.def.id, state] as [string, Forms.FieldState];\n      })\n    ),\n    errors: Forms.FieldError.noErrors,\n  };\n  return Forms.CompositeValue.set(composite, {\n    subject: Forms.generateSubjectByTemplate(subjectTemplate, ownerIri, composite),\n  });\n}\n\nexport function addField(\n  base: Forms.CompositeValue,\n  def: Forms.FieldDefinition,\n  values: ReadonlyArray<Forms.FieldValue>\n) {\n  return Forms.CompositeValue.set(base, {\n    definitions: base.definitions.set(def.id, def),\n    fields: base.fields.set(def.id, {\n      values: Immutable.List(values),\n      errors: Forms.FieldError.noErrors,\n    }),\n  });\n}\n\nfunction valueFromRdf(value: Rdf.Iri | Rdf.Literal) {\n  return Forms.FieldValue.fromLabeled({ value });\n}\n\nexport interface Annotation {\n  readonly iri: Rdf.Iri;\n  /** UI-only version key to track changes in the annotation */\n  readonly renderVersion?: number;\n  readonly selector: AnnotationSelector;\n  readonly selectedText?: string;\n  readonly bodyType?: Rdf.Iri;\n  readonly author?: Rdf.Iri;\n}\n\nexport const PLACEHOLDER_ANNOTATION = Rdf.iri('');\nexport const ANNOTATION_TO_DELETE = Rdf.iri('mp-text-annotation:to-delete');\n\nconst ANNOATIONS_QUERY = SparqlUtil.parseQuery(\n  `PREFIX oa: <http://www.w3.org/ns/oa#>\nSELECT ?annotation WHERE {\n  ?annotation oa:hasTarget ?target .\n  ?target oa:hasSource ?__documentIri__ .\n}`\n);\n\nexport function fetchAnnotations(\n  documentIri: Rdf.Iri,\n  context: SparqlClient.QueryContext,\n  selectType: (types: ReadonlyArray<Rdf.Iri>) => Rdf.Iri | undefined\n): Kefir.Property<Annotation[]> {\n  const query = SparqlClient.setBindings(ANNOATIONS_QUERY, { __documentIri__: documentIri });\n  return SparqlClient.select(query, { context })\n    .flatMap(({ results }) => {\n      const iris: Rdf.Iri[] = [];\n      for (const { annotation } of results.bindings) {\n        if (annotation && annotation.isIri()) {\n          iris.push(annotation);\n        }\n      }\n      return iris.length === 0\n        ? Kefir.constant([])\n        : Kefir.zip(iris.map((iri) => fetchAnnotation(iri, context, selectType)));\n    })\n    .toProperty();\n}\n\nconst ANNOTATION_FRAME = {\n  '@context': 'https://www.w3.org/ns/anno.jsonld',\n  '@type': 'Annotation',\n  target: {\n    source: { '@embed': '@always' },\n    selector: {},\n  },\n};\n\nfunction fetchAnnotation(\n  iri: Rdf.Iri,\n  { repository }: SparqlClient.QueryContext,\n  selectType: (types: ReadonlyArray<Rdf.Iri>) => Rdf.Iri | undefined\n): Kefir.Property<Annotation> {\n  const documentLoader = JsonLd.makeDocumentLoader({\n    overrideContexts: {\n      'https://www.w3.org/ns/anno.jsonld': JSONLD_ANNOTATION_CONTEXT,\n    },\n  });\n  const ldp = new LdpService(VocabPlatform.FormContainer.value, { repository });\n  return ldp\n    .getResourceRequest(iri.value + '/container', 'text/turtle')\n    .flatMap((ttl) =>\n      JsonLd.fromRdf(ttl, {\n        documentLoader,\n        format: 'text/turtle',\n        useNativeTypes: true,\n      })\n    )\n    .flatMap((doc) => JsonLd.frame(doc, ANNOTATION_FRAME, { documentLoader }))\n    .map(\n      (framed): Annotation => {\n        // TODO: add strict validation here\n        const anno = framed['@graph'][0];\n        const selector = anno.target.selector;\n        const types: string[] = anno.body.type\n          ? Array.isArray(anno.body.type)\n            ? anno.body.type\n            : [anno.body.type]\n          : [];\n        return {\n          iri,\n          selector: selector.type === 'RangeSelector' ? extractRangeSelector(selector) : extractPointSelector(selector),\n          selectedText: typeof anno.target.value === 'string' ? anno.target.value : undefined,\n          bodyType: selectType(types.map(Rdf.iri)),\n          author: typeof anno.carriedOutBy === 'string' ? Rdf.iri(anno.carriedOutBy) : undefined,\n        };\n      }\n    )\n    .toProperty();\n}\n\nfunction extractRangeSelector(doc: any): RangeSelector {\n  // TODO: add strict validation here\n  return {\n    type: 'range',\n    start: extractPointSelector(doc.startSelector),\n    end: extractPointSelector(doc.endSelector),\n  };\n}\n\nfunction extractPointSelector(doc: any): PointSelector {\n  // TODO: add strict validation here\n  return {\n    type: 'point',\n    xPath: doc.value,\n    offset: Number(doc.refinedBy.start),\n  };\n}\n\nexport function sameIri(a: Rdf.Iri | undefined, b: Rdf.Iri | undefined) {\n  return (a && b && a.equals(b)) || (!a && !b);\n}\n\nexport function mapIriToColor(iri: Rdf.Iri | undefined) {\n  if (!iri || !iri.value) {\n    return `rgb(52, 152, 219)`;\n  }\n  const hash = Math.abs(hashFnv32a(iri.value));\n  const value = Math.floor(hash * (Math.pow(2, 24) / Math.pow(2, 31)));\n  /* tslint:disable:no-bitwise */\n  const r = (value >> 16) & 0xff;\n  const g = (value >> 8) & 0xff;\n  const b = (value >> 0) & 0xff;\n  /* tslint:enable:no-bitwise */\n  return `rgb(${r},${g},${b})`;\n}\n\n/**\n * Calculate a 32 bit FNV-1a hash\n * Found here: https://gist.github.com/vaiorabbit/5657561\n * Ref.: http://isthe.com/chongo/tech/comp/fnv/\n *\n * @param {string} str the input value\n * @param {integer} [seed] optionally pass the hash of the previous chunk\n * @returns {integer}\n */\nfunction hashFnv32a(str: string, seed = 0x811c9dc5): number {\n  /* tslint:disable:no-bitwise */\n  let i: number,\n    l: number,\n    hval = seed & 0x7fffffff;\n\n  for (i = 0, l = str.length; i < l; i++) {\n    hval ^= str.charCodeAt(i);\n    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);\n  }\n  return hval >>> 0;\n  /* tslint:enable:no-bitwise */\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as React from 'react';\nimport * as Slate from 'slate';\nimport { rgb } from 'd3-color';\n\nimport { Rdf } from 'platform/api/rdf';\nimport * as TemplateService from 'platform/api/services/template';\nimport * as Forms from 'platform/components/forms';\n\nimport * as Schema from './AnnotationSchema';\n\nexport interface TextEditorStateProps {\n  readonly value: Slate.Value;\n  readonly annotations: ReadonlyArray<Schema.Annotation>;\n}\n\nexport interface TextEditorState extends TextEditorStateProps {\n  set(props: Partial<TextEditorStateProps>): TextEditorState;\n  addAnnotation(annotationIri: Rdf.Iri): TextEditorState;\n  updateAnnotation(target: Rdf.Iri, change: (anno: Schema.Annotation) => Schema.Annotation): TextEditorState;\n  deleteAnnotation(annotationIri: Rdf.Iri): TextEditorState;\n}\n\nexport interface WorkspacePermissions {\n  readonly userIri: Rdf.Iri | undefined;\n  readonly create: boolean;\n  readonly updateOwner: boolean;\n  readonly updateAny: boolean;\n  readonly deleteOwner: boolean;\n  readonly deleteAny: boolean;\n}\n\nexport interface WorkspaceHandlers {\n  highlightAnnotations: (highlighted: ReadonlySet<string>) => void;\n  focusAnnotation: (focused: Rdf.Iri | undefined) => void;\n  beginAddingAnnotation: () => void;\n  beginEditingAnnotation: (iri: Rdf.Iri) => void;\n  cancelEditingAnnotation: () => void;\n  persistAnnotation: (\n    target: Rdf.Iri,\n    bodyType: Rdf.Iri,\n    modelWithOnlyBody: Forms.CompositeValue\n  ) => Kefir.Property<void>;\n  deleteAnnotation: (iri: Rdf.Iri) => Kefir.Property<void>;\n}\n\nexport interface AnnotationBodyType {\n  readonly iri: Rdf.Iri;\n  readonly label: string;\n  readonly color: string;\n  readonly iconUrl: string | undefined;\n  readonly template: string;\n  readonly templateScope: TemplateService.TemplateScope | undefined;\n  readonly input: React.ReactElement<Forms.CompositeInputProps>;\n}\n\nexport interface TextAnnotationTemplateBindings {\n  /** IRI of the annotation */\n  iri: Rdf.Iri;\n  /** Type of the annotation (if known) */\n  type: Rdf.Iri | undefined;\n  /** Accent color for annotation type (user-defined or computed from type IRI) */\n  color: string;\n  /** User-defined icon URL for annotation type */\n  iconUrl: string | undefined;\n  /** True if allowed to edit the annotation; otherwise false */\n  allowEdit: boolean;\n  /** True if allowed to delete the annotation; otherwise false */\n  allowDelete: boolean;\n}\nexport namespace TextAnnotationTemplateBindings {\n  export function getAccentColor(bodyType: AnnotationBodyType | undefined, opacity = 1) {\n    const baseColor =\n      bodyType && bodyType.color ? bodyType.color : Schema.mapIriToColor(bodyType ? bodyType.iri : undefined);\n    if (opacity === 1) {\n      return baseColor;\n    }\n    const parsed = rgb(baseColor);\n    parsed.opacity = opacity;\n    return parsed.toString();\n  }\n\n  export function compute(\n    anno: Schema.Annotation,\n    bodyType: AnnotationBodyType | undefined,\n    permissions: WorkspacePermissions\n  ): TextAnnotationTemplateBindings {\n    const sameAuthor = anno.author && Schema.sameIri(permissions.userIri, anno.author);\n    const allowEdit = sameAuthor ? permissions.updateOwner : permissions.updateAny;\n    const allowDelete = sameAuthor ? permissions.deleteOwner : permissions.deleteAny;\n    return {\n      iri: anno.iri,\n      type: bodyType ? bodyType.iri : undefined,\n      color: getAccentColor(bodyType),\n      iconUrl: bodyType ? bodyType.iconUrl : undefined,\n      allowEdit,\n      allowDelete,\n    };\n  }\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Immutable from 'immutable';\nimport { sortBy } from 'lodash';\nimport * as Slate from 'slate';\n\nimport { Rdf } from 'platform/api/rdf';\n\nimport * as Schema from './AnnotationSchema';\n\nexport const ANNOTATION_RANGE_TYPE = 'rs-annotation-range';\nexport const ANNOTATION_POINT_TYPE = 'rs-annotation-point';\n\nexport type AnnotationData = Immutable.Map<string | number, any>;\nexport namespace AnnotationData {\n  export interface Props {\n    iri: Rdf.Iri;\n    bodyType: Rdf.Iri | undefined;\n    level?: number;\n    highlighted?: boolean;\n  }\n  export function create(props: Props) {\n    return Immutable.Map({ ...props });\n  }\n  export function set(data: AnnotationData, change: Partial<Props>) {\n    return create({ ...asProps(data), ...change });\n  }\n  export function asProps(data: AnnotationData) {\n    return data.toObject() as Props;\n  }\n  export function get<K extends keyof Props>(data: AnnotationData, key: K): Props[K] {\n    return data.get(key) as Props[K];\n  }\n}\n\nexport type NodeData = Immutable.Map<string | number, any>;\nexport namespace NodeData {\n  export interface Props {\n    attributes: { [attributeName: string]: any };\n    xpath: string;\n  }\n  export function create(props: Props) {\n    return Immutable.Map(props);\n  }\n  export function asProps(data: NodeData) {\n    return data.toObject() as Props;\n  }\n  export function get<K extends keyof Props>(data: NodeData, key: K): Props[K] {\n    return data.get(key) as Props[K];\n  }\n  export function set<K extends keyof Props>(data: AnnotationData, key: K, value: Props[K]): NodeData {\n    return data.set(key, value);\n  }\n}\n\nexport function assignXPaths(document: Slate.Document): Slate.Document {\n  function assingXPathToNodes(nodes: Immutable.List<Slate.Node>, parentPath: string) {\n    const makeStep = makeChildIndexTracker();\n    return nodes.map((node, index) => {\n      if (node.object === 'block' || node.object === 'inline') {\n        const path = `${parentPath}/${node.type}[${makeStep(node.type)}]`;\n        return assingXPathToNode(node, path);\n      } else {\n        return node;\n      }\n    });\n  }\n\n  type BlockOrInline = Slate.Block | Slate.Inline;\n  function assingXPathToNode(node: BlockOrInline, nodePath: string): BlockOrInline {\n    let next = node;\n    next = next.set('data', NodeData.set(node.data, 'xpath', nodePath)) as BlockOrInline;\n    next = next.set('nodes', assingXPathToNodes(next.nodes, nodePath)) as BlockOrInline;\n    return next;\n  }\n\n  function makeChildIndexTracker(): (nodeType: string) => number {\n    const map = new Map<string, number>();\n    return (nodeType: string) => {\n      const last = map.has(nodeType) ? map.get(nodeType) : 0;\n      const next = last + 1;\n      map.set(nodeType, next);\n      return next;\n    };\n  }\n\n  const resultNodes = assingXPathToNodes(document.nodes, '');\n  return Slate.Document.create({ nodes: resultNodes });\n}\n\nexport function mergeInAnnotations(doc: Slate.Document, annotations: ReadonlyArray<Schema.Annotation>): Slate.Document {\n  const { xpathToNode, xpathOrder } = findNodeXPaths(doc);\n  const nodeKeyToPath = doc.getKeysToPathsTable() as { [key: string]: Slate.Path };\n\n  let annotatedDoc = annotations.reduce((acc: Slate.Document, { iri, selector, bodyType }) => {\n    if (selector.type === 'range') {\n      const range = getRangeFromSelector(selector, xpathToNode, nodeKeyToPath);\n      if (range) {\n        return addMarksAtRange(\n          acc,\n          nodeKeyToPath,\n          range,\n          ANNOTATION_RANGE_TYPE,\n          AnnotationData.create({ iri, bodyType })\n        );\n      } else {\n        console.warn(`Cannot find annotation target in the document: `, selector);\n      }\n    }\n    return acc;\n  }, doc);\n\n  // sort point annotation in backwards order of appearance in the document\n  const pointAnnotations = sortBy(\n    annotations.filter(({ selector }) => selector.type === 'point'),\n    (annotation) => {\n      const { xPath } = annotation.selector as Schema.PointSelector;\n      const orderInDocument = xpathOrder.get(xPath);\n      return -orderInDocument;\n    }\n  );\n  annotatedDoc = pointAnnotations.reduce((acc: Slate.Document, { iri, selector, bodyType }) => {\n    const { xPath, offset } = selector as Schema.PointSelector;\n    const node = xpathToNode.get(xPath);\n    if (node) {\n      const point = getPointFromNodeOffset(node, offset, nodeKeyToPath);\n      return insertInlineAtPoint(acc, point, ANNOTATION_POINT_TYPE, AnnotationData.create({ iri, bodyType }));\n    }\n    console.warn(`Cannot find annotation target in the document: `, selector);\n    return acc;\n  }, annotatedDoc);\n\n  return annotatedDoc;\n}\n\nfunction findNodeXPaths(\n  doc: Slate.Document\n): {\n  xpathToNode: Map<string, Slate.Block | Slate.Inline>;\n  xpathOrder: Map<string, number>;\n} {\n  const xpathToNode = new Map<string, Slate.Block | Slate.Inline>();\n  const xpathOrder = new Map<string, number>();\n\n  function walkNode(node: Slate.Node) {\n    if (node.object === 'block' || node.object === 'inline') {\n      const xpath = NodeData.get(node.data, 'xpath');\n      if (xpath) {\n        xpathToNode.set(xpath, node);\n        xpathOrder.set(xpath, xpathOrder.size);\n      }\n    }\n\n    if (node.object !== 'text') {\n      (node.nodes as Immutable.List<Slate.Node>).forEach(walkNode);\n    }\n  }\n\n  walkNode(doc);\n  return { xpathToNode, xpathOrder };\n}\n\nfunction getRangeFromSelector(\n  selector: Schema.RangeSelector,\n  xpathToNode: Map<string, Slate.Block | Slate.Inline>,\n  nodeKeyToPath: { [key: string]: Slate.Path }\n): Slate.Range | undefined {\n  const startNode = xpathToNode.get(selector.start.xPath);\n  const endNode = xpathToNode.get(selector.end.xPath);\n  if (startNode && endNode) {\n    const start = getPointFromNodeOffset(startNode, selector.start.offset, nodeKeyToPath);\n    const end = getPointFromNodeOffset(endNode, selector.end.offset, nodeKeyToPath);\n    if (start && end) {\n      return Slate.Range.create({ focus: start, anchor: end });\n    }\n  }\n  return undefined;\n}\n\nfunction getPointFromNodeOffset(\n  node: Slate.Block | Slate.Inline,\n  offset: number,\n  nodeKeyToPath: { [key: string]: Slate.Path }\n): Slate.Point | undefined {\n  let length = 0;\n  let lastText: Slate.Text | undefined;\n  let text = node.getTexts().find((text, i, nodes) => {\n    length += text.text.length;\n    lastText = text;\n    return length > offset;\n  });\n  if (offset === length) {\n    text = lastText;\n  }\n  return text\n    ? Slate.Point.create({\n        key: text.key,\n        path: nodeKeyToPath[text.key],\n        offset: offset - length + text.text.length,\n      })\n    : undefined;\n}\n\nfunction incrementLastPathIndex(path: Immutable.List<number>) {\n  const index = path.size - 1;\n  return path.set(index, path.get(index) + 1);\n}\n\nexport function addMarksAtRange(\n  doc: Slate.Document,\n  nodeKeyToPath: { [key: string]: Slate.Path },\n  range: Slate.Range,\n  markType: string,\n  markData: object\n): Slate.Document {\n  return doc.getTextsAtRange(range).reduce((acc: Slate.Document, text) => {\n    const path = nodeKeyToPath[text.key];\n    if (range.start.isInNode(text) || range.end.isInNode(text)) {\n      const startOffset = range.start.isInNode(text) ? range.start.offset : 0;\n      const endOffset = range.end.isInNode(text) ? range.end.offset : text.text.length;\n      return acc.addMark(\n        path,\n        startOffset,\n        endOffset - startOffset,\n        Slate.Mark.create({ type: markType, data: markData })\n      ) as Slate.Document;\n    } else {\n      const start = Slate.Point.create({ path, offset: 0 });\n      return acc.addMark(\n        path,\n        start.offset,\n        start.moveToEndOfNode(text).offset - start.offset,\n        Slate.Mark.create({ type: markType, data: markData })\n      ) as Slate.Document;\n    }\n  }, doc);\n}\n\nexport function insertInlineAtPoint(\n  doc: Slate.Document,\n  point: Slate.Point,\n  inlineType: string,\n  inlineData: object\n): Slate.Document {\n  let changed = doc.splitNode(point.path, point.offset, undefined) as Slate.Document;\n  const splitPoint = incrementLastPathIndex(point.path as Immutable.List<number>);\n  return changed.insertNode(splitPoint, Slate.Inline.create({ type: inlineType, data: inlineData })) as Slate.Document;\n}\n\nexport function updateAnnotationLevels(doc: Slate.Document): Slate.Document {\n  const levels = findAnnotationLevels(doc);\n  return mapAnnotations(doc, (data) => {\n    const iri = AnnotationData.get(data, 'iri');\n    const annotation = levels.get(iri.value);\n    return annotation && typeof annotation.level === 'number'\n      ? AnnotationData.set(data, { level: annotation.level })\n      : data;\n  });\n}\n\ninterface ComputedAnnotation {\n  iri: Rdf.Iri;\n  level: number | undefined;\n}\n\nfunction findAnnotationLevels(doc: Slate.Document): Map<string, ComputedAnnotation> {\n  const map = new Map<string, ComputedAnnotation>();\n\n  function walkNode(node: Slate.Node) {\n    if (node.object === 'text') {\n      node.getLeaves().forEach(walkLeaf);\n    } else if (node.object === 'inline' && node.type === ANNOTATION_POINT_TYPE) {\n      const iri = AnnotationData.get(node.data, 'iri');\n      map.set(iri.value, { iri, level: undefined });\n    } else {\n      walkNodes(node.nodes as Immutable.List<Slate.Node>);\n    }\n  }\n\n  function walkLeaf(leaf: Slate.Leaf) {\n    const occupiedLevels: boolean[] = [];\n    leaf.marks.forEach((mark) => {\n      if (mark.type === ANNOTATION_RANGE_TYPE) {\n        const iri = AnnotationData.get(mark.data, 'iri');\n        const annotation = map.get(iri.value);\n        if (annotation) {\n          occupiedLevels[annotation.level] = true;\n        }\n      }\n    });\n    leaf.marks.forEach((mark) => {\n      if (mark.type === ANNOTATION_RANGE_TYPE) {\n        const iri = AnnotationData.get(mark.data, 'iri');\n        if (!map.has(iri.value)) {\n          const level = findUnoccupiedLevel(occupiedLevels);\n          occupiedLevels[level] = true;\n          map.set(iri.value, { iri, level });\n        }\n      }\n    });\n  }\n\n  function walkNodes(nodes: Immutable.List<Slate.Node>) {\n    nodes.forEach(walkNode);\n  }\n\n  function findUnoccupiedLevel(occupied: boolean[]): number {\n    for (let i = 0; i < occupied.length; i++) {\n      if (!occupied[i]) {\n        return i;\n      }\n    }\n    return occupied.length;\n  }\n\n  walkNode(doc);\n  return map;\n}\n\nexport function highlightAnnotations(doc: Slate.Document, annotationIris: ReadonlySet<string>): Slate.Document {\n  return mapAnnotations(doc, (data) => {\n    const iri = AnnotationData.get(data, 'iri');\n    const highlighted = AnnotationData.get(data, 'highlighted');\n    const isTarget = annotationIris.has(iri.value);\n    return isTarget === Boolean(highlighted) ? data : AnnotationData.set(data, { highlighted: isTarget });\n  });\n}\n\nexport function deleteAnnotation(doc: Slate.Document, annotationIri: Rdf.Iri): Slate.Document {\n  return mapAnnotations(doc, (data) => {\n    const iri = AnnotationData.get(data, 'iri');\n    return iri.equals(annotationIri) ? null : data;\n  });\n}\n\nfunction mapAnnotations(doc: Slate.Document, mapper: (data: AnnotationData) => AnnotationData | null): Slate.Document {\n  const levels = findAnnotationLevels(doc);\n\n  function mapNode(node: Slate.Node): Slate.Node | null {\n    if (node.object === 'text') {\n      const mappedLeaves = node.getLeaves().map(mapLeaf);\n      return node.setLeaves(mappedLeaves);\n    } else if (node.object === 'inline' && node.type === ANNOTATION_POINT_TYPE) {\n      const mappedData = mapper(node.data);\n      if (mappedData === null) {\n        return null;\n      } else {\n        return mappedData === node.data ? node : (node.set('data', mappedData) as Slate.Inline);\n      }\n    } else if (node.nodes.size > 0) {\n      const mappedNodes = (node.nodes as Immutable.List<Slate.Node>).map(mapNode).filter((node) => node !== null);\n      return node.set('nodes', mappedNodes) as Slate.Node;\n    }\n    return node;\n  }\n\n  function mapLeaf(leaf: Slate.Leaf) {\n    let updated = leaf;\n    leaf.marks.forEach((mark) => {\n      if (mark.type === ANNOTATION_RANGE_TYPE) {\n        const mappedData = mapper(mark.data);\n        if (mappedData === null) {\n          updated = updated.removeMark(mark);\n        } else if (mappedData !== mark.data) {\n          updated = updated.updateMark(\n            mark,\n            Slate.Mark.create({\n              type: ANNOTATION_RANGE_TYPE,\n              data: mappedData,\n            })\n          );\n        }\n      }\n    });\n    return updated;\n  }\n\n  return mapNode(doc) as Slate.Document;\n}\n\nexport function createDecorationsForRange(\n  doc: Slate.Document,\n  range: Slate.Range,\n  markType: string\n): Immutable.List<Slate.Decoration> {\n  // split range into separate decoration fro each text to avoid\n  // marking the whole block when selection crosses block boundaries\n  return doc.getTextsAtRange(range).map((text) => {\n    if (range.start.isInNode(text) || range.end.isInNode(text)) {\n      return Slate.Decoration.create({\n        anchor: range.start.isInNode(text) ? range.start : range.start.moveToStartOfNode(text).normalize(doc),\n        focus: range.end.isInNode(text) ? range.end : range.end.moveToEndOfNode(text).normalize(doc),\n        mark: Slate.Mark.create({ type: markType }),\n      });\n    } else {\n      const path = doc.getPath(text.key);\n      const start = Slate.Point.create({ key: text.key, path, offset: 0 });\n      return Slate.Decoration.create({\n        anchor: start,\n        focus: start.moveToEndOfNode(text).normalize(doc),\n        mark: Slate.Mark.create({ type: markType }),\n      });\n    }\n  });\n}\n\nexport function setValueProps(\n  value: Slate.Value,\n  props: {\n    document?: Slate.Document;\n    selection?: Slate.Selection;\n    decorations?: Immutable.List<Slate.Decoration>;\n  }\n) {\n  const { document = value.document, selection = value.selection, decorations = value.decorations } = props;\n  return Slate.Value.create({ document, selection, decorations });\n}\n\nexport function sortAnnotationsByFirstOccurence(\n  doc: Slate.Document,\n  annotations: ReadonlyArray<Schema.Annotation>\n): Schema.Annotation[] {\n  const order = new Map<string, number>();\n  mapAnnotations(doc, (data) => {\n    order.set(AnnotationData.get(data, 'iri').value, order.size);\n    return data;\n  });\n  const result = [...annotations];\n  result.sort((a, b) => {\n    const i = order.get(a.iri.value);\n    const j = order.get(b.iri.value);\n    return i < j ? -1 : i > j ? 1 : 0;\n  });\n  return result;\n}\n\nexport function updateAnnotation(doc: Slate.Document, target: Rdf.Iri, annotation: Schema.Annotation): Slate.Document {\n  return mapAnnotations(doc, (data) => {\n    const iri = AnnotationData.get(data, 'iri');\n    return iri.equals(target) ? AnnotationData.set(data, { iri: annotation.iri, bodyType: annotation.bodyType }) : data;\n  });\n}\n\nexport function extractTextFragment(doc: Slate.Document, range: Slate.Range): string {\n  return doc\n    .getFragmentAtRange(range)\n    .getBlocks()\n    .map((b) => b.text)\n    .join(' ');\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as Kefir from 'kefir';\nimport * as React from 'react';\nimport ReactSelect, { Option } from 'react-select';\n\nimport { Component } from 'platform/api/components';\nimport { Rdf, vocabularies } from 'platform/api/rdf';\nconst { oa } = vocabularies;\n\nimport * as Forms from 'platform/components/forms';\n\nimport { crmdig } from 'platform/data/vocabularies';\n\nimport * as Schema from '../model/AnnotationSchema';\nimport { WorkspaceHandlers, AnnotationBodyType } from '../model/ComponentModel';\n\nimport * as styles from './AnnotationEditForm.scss';\n\nexport interface AnnotationEditFormProps {\n  subject: Rdf.Iri | undefined;\n  subjectTemplate: string;\n  selectedText: string | undefined;\n  annotationBodyType: Rdf.Iri | undefined;\n  annotationTypes: ReadonlyMap<string, AnnotationBodyType>;\n  handlers: WorkspaceHandlers;\n}\n\ninterface State {\n  formKey?: number;\n  selectedBodyType?: Rdf.Iri;\n}\n\nexport class AnnotationEditForm extends Component<AnnotationEditFormProps, State> {\n  private static readonly FIELDS: ReadonlyArray<Forms.FieldDefinition> = [Schema.RdfType, Schema.OAHasBody];\n\n  constructor(props: AnnotationEditFormProps, context: any) {\n    super(props, context);\n    this.state = {\n      formKey: 0,\n      selectedBodyType: this.props.annotationBodyType,\n    };\n  }\n\n  componentWillReceiveProps(nextProps: AnnotationEditFormProps) {\n    if (!Schema.sameIri(this.props.annotationBodyType, nextProps.annotationBodyType)) {\n      this.setState(\n        (state): State => ({\n          formKey: state.formKey + 1,\n          selectedBodyType: nextProps.annotationBodyType,\n        })\n      );\n    }\n  }\n\n  render() {\n    const { subject, subjectTemplate, annotationTypes, handlers } = this.props;\n    const { formKey, selectedBodyType } = this.state;\n    const metadata = selectedBodyType ? annotationTypes.get(selectedBodyType.value) : undefined;\n    return (\n      <Forms.ResourceEditorForm\n        key={formKey}\n        fields={AnnotationEditForm.FIELDS}\n        subject={subject}\n        newSubjectTemplate={subjectTemplate}\n        postAction=\"none\"\n        persistence={{\n          persist: (intialModel, currentModel) => {\n            if (!selectedBodyType) {\n              return Kefir.constantError<any>(new Error('Missing annotation type'));\n            }\n            if (Forms.FieldValue.isEmpty(currentModel)) {\n              return Kefir.constant(undefined);\n            }\n            return handlers.persistAnnotation(subject, selectedBodyType, currentModel);\n          },\n          remove: (currentModel) => {\n            // TODO implement remove annotation\n            return undefined;\n          }\n        }}\n      >\n        <div className={styles.formContent}>\n          {this.props.selectedText ? (\n            <div className={styles.selectedFragment}>\n              Selected fragment:\n              <div className={styles.selectedFragmentText}>{this.props.selectedText}</div>\n            </div>\n          ) : null}\n          {this.renderBodyTypeSelector()}\n          <Forms.HiddenInput\n            for={Schema.RdfType.id}\n            defaultValues={[oa.Annotation.value, crmdig.D29_Annotation_Object.value]}\n          />\n          <div className={styles.bodyInput}>\n            {metadata ? React.cloneElement(metadata.input as any, { renderHeader: false }) : null}\n          </div>\n        </div>\n        <button name=\"submit\" className=\"btn btn-primary\">\n          {Schema.sameIri(subject, Schema.PLACEHOLDER_ANNOTATION) ? 'Create annotation' : 'Update annotation'}\n        </button>\n        <button className={`btn btn-default ${styles.cancelButton}`} onClick={handlers.cancelEditingAnnotation}>\n          Cancel\n        </button>\n      </Forms.ResourceEditorForm>\n    );\n  }\n\n  private renderBodyTypeSelector() {\n    const { annotationTypes } = this.props;\n    const { selectedBodyType } = this.state;\n\n    interface TypeOption extends Option<string> {\n      type: AnnotationBodyType;\n    }\n\n    const options: TypeOption[] = [];\n    annotationTypes.forEach((type) => {\n      options.push({ type, value: type.iri.value, label: type.label });\n    });\n\n    const optionRenderer = (option: Option): JSX.Element => {\n      const { type } = option as TypeOption;\n      return (\n        <div>\n          {type.iconUrl ? <img className={styles.bodyTypeIcon} src={type.iconUrl} /> : null}\n          {type.label}\n        </div>\n      );\n    };\n\n    return (\n      <ReactSelect\n        clearable={false}\n        placeholder=\"Select annotation type...\"\n        value={selectedBodyType ? selectedBodyType.value : undefined}\n        options={options}\n        optionRenderer={optionRenderer}\n        valueRenderer={optionRenderer}\n        onChange={(newValue) => {\n          if (Array.isArray(newValue) || typeof newValue.value !== 'string') {\n            return;\n          }\n          const type = annotationTypes.get(newValue.value);\n          this.setState(\n            (state): State => ({\n              formKey: state.formKey + 1,\n              selectedBodyType: type.iri,\n            })\n          );\n        }}\n      />\n    );\n  }\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as classnames from 'classnames';\nimport * as React from 'react';\nimport { Badge, Nav, NavItem, Tab } from 'react-bootstrap';\n\nimport { Component, ComponentProps } from 'platform/api/components';\nimport { Rdf } from 'platform/api/rdf';\n\nimport { TemplateItem } from 'platform/components/ui/template';\n\nimport * as Schema from '../model/AnnotationSchema';\nimport {\n  WorkspacePermissions,\n  WorkspaceHandlers,\n  AnnotationBodyType,\n  TextAnnotationTemplateBindings,\n} from '../model/ComponentModel';\n\nimport * as styles from './AnnotationSidebar.scss';\n\nexport interface AnnotationSidebarProps {\n  className?: string;\n  annotationTypes: ReadonlyMap<string, AnnotationBodyType>;\n  fallbackTemplate: string;\n  annotations: ReadonlyArray<Schema.Annotation>;\n  focusedAnnotation?: Rdf.Iri;\n  highlightedAnnotations: ReadonlySet<string>;\n  permissions: WorkspacePermissions;\n  handlers: WorkspaceHandlers;\n}\n\ninterface State {\n  selectedTab?: string;\n}\n\nconst ALL_TYPES_TAB = 'all';\n\nexport class AnnotationSidebar extends Component<AnnotationSidebarProps, State> {\n  private annotationList: HTMLElement | null;\n\n  constructor(props: AnnotationSidebarProps, context: any) {\n    super(props, context);\n    this.state = {\n      selectedTab: ALL_TYPES_TAB,\n    };\n  }\n\n  componentDidUpdate(prevProps: AnnotationSidebarProps) {\n    const { focusedAnnotation } = this.props;\n    if (focusedAnnotation && !Schema.sameIri(focusedAnnotation, prevProps.focusedAnnotation)) {\n      this.scrollAnnotationIntoView(focusedAnnotation);\n    }\n  }\n\n  render() {\n    const { className, annotationTypes, annotations, focusedAnnotation, highlightedAnnotations } = this.props;\n    const { selectedTab } = this.state;\n    return (\n      <div className={classnames(styles.component, className)}>\n        <Tab.Container\n          id=\"rs-text-annotation-types\"\n          activeKey={selectedTab}\n          // type cast as workaround to wrong React Bootstrap typings\n          onSelect={this.onSelectTab as (e: any) => void}\n        >\n          <Nav bsStyle=\"tabs\">\n            <NavItem eventKey={ALL_TYPES_TAB} title=\"All annotations\">\n              all\n            </NavItem>\n            {Array.from(annotationTypes.values(), (type) => {\n              const count = countAnnotationForTab(annotations, type.iri.value);\n              return (\n                <NavItem key={type.iri.value} eventKey={type.iri.value} disabled={count === 0} title={type.label}>\n                  <div className={styles.tabHeader}>\n                    {type.iconUrl ? <img className={styles.tabIcon} src={type.iconUrl} /> : <span>{type.label}</span>}\n                  </div>\n                </NavItem>\n              );\n            })}\n          </Nav>\n        </Tab.Container>\n        <div className={styles.annotationList} ref={this.onAnnotationListMount}>\n          {annotations.map((anno) => {\n            return this.renderAnnotation(anno, {\n              hidden: !shouldRenderInTab(anno, selectedTab),\n              focused: Schema.sameIri(anno.iri, focusedAnnotation),\n              highlighted: highlightedAnnotations.size === 0 || highlightedAnnotations.has(anno.iri.value),\n            });\n          })}\n        </div>\n      </div>\n    );\n  }\n\n  private onAnnotationListMount = (annotationList: HTMLElement | null) => {\n    this.annotationList = annotationList;\n  };\n\n  private onSelectTab = (tabKey: string) => {\n    this.setState({ selectedTab: tabKey });\n  };\n\n  private renderAnnotation(\n    annotation: Schema.Annotation,\n    options: {\n      hidden: boolean;\n      focused: boolean;\n      highlighted: boolean;\n    }\n  ) {\n    const { annotationTypes, fallbackTemplate: defaultTemplate, permissions } = this.props;\n\n    const isPlaceholder = Schema.sameIri(annotation.iri, Schema.PLACEHOLDER_ANNOTATION);\n\n    const bodyType = annotation.bodyType;\n    const bodyTypeMetadata = bodyType ? annotationTypes.get(bodyType.value) : undefined;\n\n    const className = classnames(styles.annotation, {\n      [styles.focused]: options.focused,\n      [styles.highlighted]: options.highlighted,\n    });\n    return (\n      <div\n        key={annotation.iri.value}\n        data-annotation-iri={annotation.iri.value}\n        className={className}\n        style={options.hidden ? { display: 'none' } : undefined}\n        onClick={this.onClickInsideAnnotation}\n      >\n        {isPlaceholder ? (\n          // render placeholder for new annotation\n          <div className={styles.newAnnotationPlaceholder}>New annotation</div>\n        ) : null}\n\n        {!isPlaceholder && bodyTypeMetadata ? (\n          // render template for existing annotation with known body type\n          <TemplateScopeProvider markupTemplateScope={bodyTypeMetadata.templateScope}>\n            <TemplateItem\n              key={annotation.renderVersion}\n              template={{\n                source: bodyTypeMetadata.template,\n                options: TextAnnotationTemplateBindings.compute(annotation, bodyTypeMetadata, permissions),\n              }}\n            />\n          </TemplateScopeProvider>\n        ) : null}\n\n        {!isPlaceholder && !bodyTypeMetadata ? (\n          // render template for existing annotation with unknown body type\n          <TemplateItem\n            template={{\n              source: defaultTemplate,\n              options: TextAnnotationTemplateBindings.compute(annotation, bodyTypeMetadata, permissions),\n            }}\n          />\n        ) : null}\n      </div>\n    );\n  }\n\n  private onClickInsideAnnotation = (e: React.MouseEvent<HTMLElement>) => {\n    const { handlers } = this.props;\n    const target = e.target;\n    if (target instanceof HTMLButtonElement) {\n      const iri = target.getAttribute('data-annotation');\n      if (iri) {\n        if (target.name === 'edit') {\n          handlers.beginEditingAnnotation(Rdf.iri(iri));\n        } else if (target.name === 'delete') {\n          handlers.deleteAnnotation(Rdf.iri(iri));\n        }\n      }\n    }\n  };\n\n  private scrollAnnotationIntoView(target: Rdf.Iri) {\n    if (!this.annotationList) {\n      return;\n    }\n    const listBounds = this.annotationList.getBoundingClientRect();\n    const elements = this.annotationList.children;\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i] as HTMLElement;\n      const iri = element.getAttribute('data-annotation-iri');\n      if (iri === target.value) {\n        const elementBounds = element.getBoundingClientRect();\n        const elementTop = elementBounds.top - listBounds.top;\n        const listScrollTop = this.annotationList.scrollTop;\n        const listScrollBottom = listScrollTop + listBounds.height;\n        const isOutsideView = elementTop < listScrollTop || elementTop + elementBounds.height > listScrollBottom;\n        if (isOutsideView) {\n          this.annotationList.scrollTop = elementTop;\n        }\n      }\n    }\n  }\n}\n\nclass TemplateScopeProvider extends Component<ComponentProps, {}> {\n  render() {\n    return React.Children.only(this.props.children);\n  }\n}\n\nfunction shouldRenderInTab(annotation: Schema.Annotation, tabKey: string) {\n  return tabKey === ALL_TYPES_TAB || (annotation.bodyType && annotation.bodyType.value === tabKey);\n}\n\nfunction countAnnotationForTab(annotations: ReadonlyArray<Schema.Annotation>, tabKey: string) {\n  if (tabKey === ALL_TYPES_TAB) {\n    return annotations.length;\n  }\n  let count = 0;\n  for (const anno of annotations) {\n    if (anno.bodyType && anno.bodyType.value === tabKey) {\n      count++;\n    }\n  }\n  return count;\n}\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport * as classnames from 'classnames';\nimport * as Kefir from 'kefir';\nimport * as React from 'react';\nimport { Button } from 'react-bootstrap';\nimport * as Immutable from 'immutable';\nimport * as Slate from 'slate';\nimport { Editor, RenderNodeProps, RenderMarkProps, RenderAttributes, findDOMRange } from 'slate-react';\n\nimport { Cancellation } from 'platform/api/async';\nimport { Component } from 'platform/api/components';\nimport { Rdf } from 'platform/api/rdf';\n\nimport { TemplateItem } from 'platform/components/ui/template';\nimport { TargetedPopover } from 'platform/components/ui/TargetedPopover';\n\nimport * as Schema from '../model/AnnotationSchema';\nimport {\n  TextEditorState,\n  TextEditorStateProps,\n  AnnotationBodyType,\n  TextAnnotationTemplateBindings,\n  WorkspacePermissions,\n  WorkspaceHandlers,\n} from '../model/ComponentModel';\nimport { AnnotationData, NodeData, ANNOTATION_POINT_TYPE, ANNOTATION_RANGE_TYPE } from '../model/EditorModel';\nimport * as EditorModel from '../model/EditorModel';\nimport { BLOCK_TAGS, INLINE_TAGS, MARK_TAGS, SLATE_HTML } from '../model/TextSerialization';\n\nimport * as styles from './TextAnnotationEditor.scss';\n\nexport interface TextAnnotationEditorProps {\n  className?: string;\n  editorState: TextEditorState;\n  onEditorStateChange: (newState: TextEditorState) => void;\n  annotationTypes: ReadonlyMap<string, AnnotationBodyType>;\n  tooltipTemplate?: string;\n  permissions: WorkspacePermissions;\n  handlers: WorkspaceHandlers;\n}\n\ninterface State {\n  selectionTopOffset?: number;\n}\n\nconst EMPTY_SET = new Set<string>();\n\nexport class TextAnnotationEditor extends Component<TextAnnotationEditorProps, State> {\n  editor: Editor;\n\n  private debounceTooltip: Cancellation = new Cancellation();\n  private sideline: HTMLElement | null | undefined;\n\n  constructor(props: TextAnnotationEditorProps, context: any) {\n    super(props, context);\n    this.state = {};\n  }\n\n  componentDidMount() {\n    const { editorState, onEditorStateChange } = this.props;\n    onEditorStateChange(EditorState.set(editorState, { owner: this }));\n  }\n\n  onChange = (change: { operations: Immutable.List<Slate.Operation>; value: Slate.Value }) => {\n    const { editorState, onEditorStateChange } = this.props;\n    const nextState = editorState.set({ value: change.value });\n    onEditorStateChange(nextState);\n  };\n\n  render() {\n    const { className, editorState, permissions } = this.props;\n    const { selectionTopOffset } = this.state;\n    return (\n      <div className={classnames(styles.component, className)}>\n        <div className={styles.textEditor}>\n          <Editor\n            ref={this.onEditorMount}\n            spellCheck={false}\n            value={editorState.value}\n            onChange={this.onChange}\n            onKeyDown={this.onKeyDown}\n            onClick={this.onTextClick}\n            onDragStart={this.ignoreIfReadonly}\n            onCut={this.ignoreIfReadonly}\n            onPaste={this.ignoreIfReadonly}\n            onSelect={this.onSelect}\n            renderNode={this.renderNode}\n            renderMark={this.renderMark}\n          />\n          <div className={styles.addAnnotationSideline} ref={this.onSidelineMount}>\n            {permissions.create && selectionTopOffset > 0 ? (\n              <Button\n                className={styles.addAnnotationButton}\n                style={{ top: selectionTopOffset }}\n                title=\"Add annotation\"\n                onClick={this.onAddAnnotationClick}\n              >\n                <span className={styles.addAnnotationIcon} />\n              </Button>\n            ) : null}\n          </div>\n        </div>\n        {this.renderTooltip()}\n      </div>\n    );\n  }\n\n  private onSidelineMount = (sideline: HTMLElement | null) => {\n    this.sideline = sideline;\n  };\n\n  private renderTooltip() {\n    const { editorState, tooltipTemplate, annotationTypes, permissions } = this.props;\n    const { tooltip } = editorState as EditorState;\n    if (!(tooltip && tooltipTemplate)) {\n      return null;\n    }\n    const anno = tooltip.annotations.length > 0 ? tooltip.annotations[0] : undefined;\n    const bodyType = anno.bodyType ? annotationTypes.get(anno.bodyType.value) : undefined;\n    return (\n      <div style={{ position: 'fixed', left: 0, top: 0 }}>\n        <TargetedPopover\n          key={`${tooltip.left};${tooltip.top}`}\n          id=\"text-annotation-editor-tooltip\"\n          hideTimeout={500}\n          targetLeft={tooltip.left}\n          targetTop={tooltip.top}\n          popoverSide=\"top\"\n          arrowAlignment=\"center\"\n          onHide={tooltip.hovering ? undefined : this.onTooltipHide}\n        >\n          <TemplateItem\n            componentProps={{ onClick: this.onTooltipClick }}\n            template={{\n              source: tooltipTemplate,\n              options: TextAnnotationTemplateBindings.compute(anno, bodyType, permissions),\n            }}\n          />\n        </TargetedPopover>\n      </div>\n    );\n  }\n\n  private onKeyDown = (event: Event, editor: Slate.Editor, next: () => void) => {\n    const keyboarEvent = event as KeyboardEvent;\n    const isCopyKeyCombination =\n      (keyboarEvent.ctrlKey || keyboarEvent.metaKey) && keyboarEvent.keyCode === 67 /* \"C\" key */;\n    if (!isCopyKeyCombination) {\n      // ignore event\n      event.preventDefault();\n      return true;\n    }\n  };\n\n  private onTextClick = (event: Event, editor: Slate.Editor, next: () => void) => {\n    // click events on annotated text will be handled before and won't propagate here\n    this.props.handlers.focusAnnotation(undefined);\n  };\n\n  private ignoreIfReadonly = (event: Event, editor: Slate.Editor, next: () => void) => {\n    // ignore event\n    event.preventDefault();\n    return true;\n  };\n\n  private onEditorMount = (editor: Editor) => {\n    this.editor = editor;\n  };\n\n  private renderNode = (props: RenderNodeProps, editor: Slate.Editor, next: () => any) => {\n    const { node, attributes, children } = props;\n    if (BLOCK_TAGS[node.type] || INLINE_TAGS[node.type]) {\n      return React.createElement(node.type, { ...NodeData.get(node.data, 'attributes'), ...attributes }, children);\n    } else if (node.object === 'inline' && node.type === AnnotationInline.TAG_NAME) {\n      return (\n        <AnnotationInline\n          inline={node}\n          attributes={attributes}\n          getAnnotationType={this.getAnnotationType}\n          onClick={this.onClickAnnotation}\n          onStartHovering={this.onStartHoveringAnnotation}\n          onStopHovering={this.onStopHoveringAnnotation}\n        >\n          {children}\n        </AnnotationInline>\n      );\n    } else {\n      return next();\n    }\n  };\n\n  private renderMark = (props: RenderMarkProps, editor: Slate.Editor, next: () => any) => {\n    const { mark, marks, attributes, children } = props;\n    if (MARK_TAGS[mark.type]) {\n      return React.createElement(mark.type, { ...NodeData.get(mark.data, 'attributes'), ...attributes }, children);\n    } else if (mark.type === AnnotationMark.TAG_NAME) {\n      return (\n        <AnnotationMark\n          mark={mark}\n          marks={marks}\n          attributes={attributes}\n          getAnnotationType={this.getAnnotationType}\n          onClick={this.onClickAnnotation}\n          onStartHovering={this.onStartHoveringAnnotation}\n          onStopHovering={this.onStopHoveringAnnotation}\n        >\n          {children}\n        </AnnotationMark>\n      );\n    } else {\n      return next();\n    }\n  };\n\n  private onSelect = (event: Event, editor: Slate.Editor, next: () => void) => {\n    next();\n\n    const state = this.props.editorState as EditorState;\n\n    if (!editor.value.selection.equals(state.markedSelection)) {\n      this.debounceTooltip.cancelAll();\n      this.debounceTooltip = new Cancellation();\n      this.debounceTooltip.map(Kefir.later(0, true)).observe({\n        value: () => {\n          this.updateSelectionOffset(editor);\n        },\n      });\n    }\n  };\n\n  private updateSelectionOffset(editor: Slate.Editor) {\n    if (!this.sideline) {\n      return;\n    }\n    const { start, end } = editor.value.selection;\n    const range = Slate.Range.create({ anchor: start, focus: end });\n    // Return type in typings is wrong and should be Range, not Slate.Range:\n    // https://docs.slatejs.org/slate-react/utils\n    const domRange = (findDOMRange(range) as any) as Range;\n    const rect = domRange.getBoundingClientRect();\n    const selectionTop = rect.top + rect.height / 2;\n    const sidelineTop = this.sideline.getBoundingClientRect().top;\n    const selectionTopOffset = selectionTop - sidelineTop;\n    this.setState({ selectionTopOffset });\n  }\n\n  private onAddAnnotationClick = () => {\n    const {\n      handlers: { beginAddingAnnotation },\n    } = this.props;\n    beginAddingAnnotation();\n    this.setState({ selectionTopOffset: 0 });\n  };\n\n  private getAnnotationType = (bodyType: Rdf.Iri | undefined): AnnotationBodyType | undefined => {\n    if (!bodyType) {\n      return undefined;\n    }\n    return this.props.annotationTypes.get(bodyType.value);\n  };\n\n  private onClickAnnotation = (data: AnnotationData) => {\n    this.props.handlers.focusAnnotation(AnnotationData.get(data, 'iri'));\n  };\n\n  private onStartHoveringAnnotation = (hoverState: HoverState) => {\n    const { editorState, onEditorStateChange, handlers } = this.props;\n\n    const hovered = new Set<string>(hoverState.iris.map((iri) => iri.value));\n    handlers.highlightAnnotations(hovered);\n\n    const annotations = editorState.annotations.filter((anno) => hovered.has(anno.iri.value));\n    const highlightedDoc = EditorModel.highlightAnnotations(editorState.value.document, hovered);\n    const nextState = EditorState.set(editorState, {\n      value: EditorModel.setValueProps(editorState.value, { document: highlightedDoc }),\n      tooltip: { ...hoverState, annotations },\n    });\n    onEditorStateChange(nextState);\n  };\n\n  private onStopHoveringAnnotation = () => {\n    const { editorState, onEditorStateChange, handlers } = this.props;\n\n    handlers.highlightAnnotations(EMPTY_SET);\n    const unhighlightedDoc = EditorModel.highlightAnnotations(editorState.value.document, EMPTY_SET);\n    const previousState = editorState as EditorState;\n    if (previousState.tooltip) {\n      const nextState = EditorState.set(previousState, {\n        value: EditorModel.setValueProps(editorState.value, { document: unhighlightedDoc }),\n        tooltip: { ...previousState.tooltip, hovering: false },\n      });\n      onEditorStateChange(nextState);\n    }\n  };\n\n  private onTooltipHide = () => {\n    const { editorState, onEditorStateChange } = this.props;\n    const nextState = EditorState.set(editorState, { tooltip: undefined });\n    onEditorStateChange(nextState);\n  };\n\n  private onTooltipClick = (e: React.MouseEvent<HTMLElement>) => {\n    const { handlers } = this.props;\n    const target = e.target;\n    if (target instanceof HTMLButtonElement) {\n      const iri = target.getAttribute('data-annotation');\n      if (iri) {\n        if (target.name === 'edit') {\n          handlers.beginEditingAnnotation(Rdf.iri(iri));\n        } else if (target.name === 'delete') {\n          handlers.deleteAnnotation(Rdf.iri(iri));\n        }\n      }\n    }\n  };\n}\n\ninterface AdditionalEditorState {\n  readonly owner: TextAnnotationEditor | undefined;\n  readonly markedSelection: Slate.Selection | undefined;\n  readonly tooltip: TooltipState | undefined;\n}\n\ninterface HoverState {\n  readonly left: number;\n  readonly top: number;\n  readonly hovering: boolean;\n  readonly iris: ReadonlyArray<Rdf.Iri>;\n}\n\ninterface TooltipState extends HoverState {\n  readonly annotations: ReadonlyArray<Schema.Annotation>;\n}\n\nclass EditorState implements TextEditorState, AdditionalEditorState {\n  readonly value: Slate.Value;\n  readonly annotations: ReadonlyArray<Schema.Annotation>;\n  readonly owner: TextAnnotationEditor | undefined;\n  readonly markedSelection: Slate.Selection | undefined;\n  readonly tooltip: TooltipState | undefined;\n\n  private constructor(props: TextEditorStateProps & Partial<AdditionalEditorState>) {\n    this.value = props.value;\n    this.annotations = props.annotations;\n    this.owner = props.owner;\n    this.markedSelection = props.markedSelection;\n    this.tooltip = props.tooltip;\n  }\n\n  static create(props: TextEditorStateProps & Partial<AdditionalEditorState>) {\n    return new EditorState(props);\n  }\n\n  static set(\n    base: TextEditorStateProps & Partial<AdditionalEditorState>,\n    override: Partial<TextEditorStateProps> & Partial<AdditionalEditorState>\n  ): EditorState {\n    const baseProps: TextEditorStateProps & Partial<AdditionalEditorState> = {\n      value: base.value,\n      annotations: base.annotations,\n      owner: base.owner,\n      markedSelection: base.markedSelection,\n      tooltip: base.tooltip,\n    };\n    return new EditorState({ ...baseProps, ...override });\n  }\n\n  set(props: Partial<TextEditorStateProps>): TextEditorState {\n    return EditorState.set(this, props);\n  }\n\n  addAnnotation(annotationIri: Rdf.Iri): EditorState {\n    const { document, selection } = this.value;\n    const { start, end } = selection;\n\n    let nextDocument: Slate.Document;\n    let selector: Schema.AnnotationSelector;\n    let selectedText: string | undefined;\n\n    if (selection.isExpanded) {\n      const nodeKeyToPath = document.getKeysToPathsTable() as { [key: string]: Slate.Path };\n      const range = Slate.Range.create({\n        anchor: selection.start,\n        focus: selection.end,\n      });\n      nextDocument = EditorModel.addMarksAtRange(\n        document,\n        nodeKeyToPath,\n        range,\n        ANNOTATION_RANGE_TYPE,\n        AnnotationData.create({ iri: annotationIri, bodyType: undefined })\n      );\n      selector = {\n        type: 'range',\n        start: {\n          type: 'point',\n          xPath: findXPathAt(document, start.path),\n          offset: start.offset,\n        },\n        end: {\n          type: 'point',\n          xPath: findXPathAt(document, end.path),\n          offset: end.offset,\n        },\n      };\n      selectedText = EditorModel.extractTextFragment(document, range);\n    } else {\n      nextDocument = EditorModel.insertInlineAtPoint(\n        document,\n        selection.start,\n        ANNOTATION_POINT_TYPE,\n        AnnotationData.create({ iri: annotationIri, bodyType: undefined })\n      );\n      selector = {\n        type: 'point',\n        xPath: findXPathAt(document, start.path),\n        offset: start.offset,\n      };\n    }\n\n    const annotation: Schema.Annotation = { iri: annotationIri, selector, selectedText };\n    const annotations = EditorModel.sortAnnotationsByFirstOccurence(nextDocument, [...this.annotations, annotation]);\n\n    return EditorState.set(this, {\n      value: EditorModel.setValueProps(this.value, {\n        document: nextDocument,\n      }),\n      annotations,\n    });\n  }\n\n  updateAnnotation(target: Rdf.Iri, change: (anno: Schema.Annotation) => Schema.Annotation): EditorState {\n    let changed: Schema.Annotation | undefined;\n    const annotations = this.annotations.map(\n      (anno): Schema.Annotation => {\n        if (anno.iri.equals(target)) {\n          changed = change(anno);\n          return changed;\n        }\n        return anno;\n      }\n    );\n    if (!changed) {\n      return this;\n    }\n    const value = EditorModel.setValueProps(this.value, {\n      document: EditorModel.updateAnnotation(this.value.document, target, changed),\n    });\n    return EditorState.set(this, { value, annotations });\n  }\n\n  deleteAnnotation(annotationIri: Rdf.Iri): EditorState {\n    if (this.annotations.find((anno) => anno.iri.equals(annotationIri))) {\n      const value = EditorModel.setValueProps(this.value, {\n        document: EditorModel.deleteAnnotation(this.value.document, annotationIri),\n      });\n      const annotations = this.annotations.filter((anno) => !anno.iri.equals(annotationIri));\n      return EditorState.set(this, { value, annotations, tooltip: undefined });\n    }\n    return this;\n  }\n}\n\nfunction findXPathAt(document: Slate.Document, path: Slate.Path) {\n  const parentNode = document.getAncestors(path).last();\n  if (!(parentNode.object === 'block' || parentNode.object === 'inline')) {\n    throw new Error(`Unexpected parent node type: ${parentNode.object}`);\n  }\n  const xpath = NodeData.get(parentNode.data, 'xpath');\n  if (!xpath) {\n    throw new Error(`Failed to find XPath at selected node`);\n  }\n  return xpath;\n}\n\nexport function makeIntitialEditorState(params: {\n  sourceHtml: string;\n  annotations: ReadonlyArray<Schema.Annotation>;\n}): TextEditorState {\n  const rawValue = SLATE_HTML.deserialize(params.sourceHtml);\n  let { document } = rawValue;\n  document = EditorModel.assignXPaths(document);\n  document = EditorModel.mergeInAnnotations(document, params.annotations);\n  document = EditorModel.updateAnnotationLevels(document);\n\n  const annotations = EditorModel.sortAnnotationsByFirstOccurence(document, params.annotations);\n\n  return EditorState.create({\n    value: Slate.Value.create({ document }),\n    annotations,\n  });\n}\n\ninterface AnnotationMarkProps {\n  mark: Slate.Mark;\n  marks: Immutable.Set<Slate.Mark>;\n  attributes: RenderAttributes;\n  getAnnotationType: (bodyType: Rdf.Iri | undefined) => AnnotationBodyType | undefined;\n  onClick: (data: AnnotationData) => void;\n  onStartHovering: (tooltip: HoverState) => void;\n  onStopHovering: () => void;\n}\n\nclass AnnotationMark extends React.Component<AnnotationMarkProps, {}> {\n  static readonly TAG_NAME = 'rs-annotation-range';\n\n  render() {\n    const { mark, children, attributes, getAnnotationType } = this.props;\n    const { iri, bodyType, level, highlighted } = AnnotationData.asProps(mark.data);\n    const type = getAnnotationType(bodyType);\n    const BORDER_OFFSET = 3;\n    return (\n      <span\n        {...attributes}\n        onClick={this.onClick}\n        onMouseEnter={this.onMouseEnter}\n        onMouseLeave={this.onMouseLeave}\n        style={{\n          paddingBottom: 1 + (typeof level === 'number' ? level : 0) * BORDER_OFFSET,\n          borderBottom: '2px solid',\n          borderColor: TextAnnotationTemplateBindings.getAccentColor(type),\n          backgroundColor: highlighted ? TextAnnotationTemplateBindings.getAccentColor(type, 0.3) : undefined,\n        }}\n      >\n        {children}\n      </span>\n    );\n  }\n\n  private onClick = (e: React.MouseEvent<{}>) => {\n    // prevent event bubbling to handle click on non-annotated text\n    e.stopPropagation();\n    this.props.onClick(this.props.mark.data);\n  };\n\n  private onMouseEnter = (event: React.MouseEvent<HTMLSpanElement>) => {\n    const target = event.currentTarget;\n    const rect = target.getBoundingClientRect();\n    this.props.onStartHovering({\n      left: (rect.left + rect.right) / 2,\n      top: rect.top,\n      hovering: true,\n      iris: this.props.marks\n        .filter((mark) => mark.type === ANNOTATION_RANGE_TYPE)\n        .map((mark) => AnnotationData.get(mark.data, 'iri'))\n        .toArray(),\n    });\n  };\n\n  private onMouseLeave = () => {\n    this.props.onStopHovering();\n  };\n}\n\ninterface AnnotationInlineProps {\n  inline: Slate.Inline;\n  attributes: RenderAttributes;\n  getAnnotationType: (bodyType: Rdf.Iri | undefined) => AnnotationBodyType | undefined;\n  onClick: (data: AnnotationData) => void;\n  onStartHovering: (tooltip: HoverState) => void;\n  onStopHovering: () => void;\n}\n\nclass AnnotationInline extends React.Component<AnnotationInlineProps, {}> {\n  static readonly TAG_NAME = 'rs-annotation-point';\n\n  render() {\n    const { inline, children, attributes, getAnnotationType } = this.props;\n    const { iri, highlighted, bodyType } = AnnotationData.asProps(inline.data);\n    const type = getAnnotationType(bodyType);\n    const backgroundColor = TextAnnotationTemplateBindings.getAccentColor(type, highlighted ? 1 : 0.5);\n    const className = attributes.className\n      ? `${attributes.className} ${styles.pointAnnotation}`\n      : styles.pointAnnotation;\n    return (\n      <span\n        {...attributes}\n        className={className}\n        onClick={this.onClick}\n        onMouseEnter={this.onMouseEnter}\n        onMouseLeave={this.onMouseLeave}\n        style={{ backgroundColor }}\n      >\n        {children}\n      </span>\n    );\n  }\n\n  private onClick = (e: React.MouseEvent<{}>) => {\n    // prevent event bubbling to handle click on non-annotated text\n    e.stopPropagation();\n    this.props.onClick(this.props.inline.data);\n  };\n\n  private onMouseEnter = (event: React.MouseEvent<HTMLSpanElement>) => {\n    const target = event.currentTarget;\n    const rect = target.getBoundingClientRect();\n    this.props.onStartHovering({\n      left: (rect.left + rect.right) / 2,\n      top: rect.top,\n      hovering: true,\n      iris: [AnnotationData.get(this.props.inline.data, 'iri')],\n    });\n  };\n\n  private onMouseLeave = () => {\n    this.props.onStopHovering();\n  };\n}\n\nexport default TextAnnotationEditor;\n","/**\n * ResearchSpace\n * Copyright (C) 2015-2020, Â© Trustees of the British Museum\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport Html, { Rule } from 'slate-html-serializer';\n\nimport { ModuleRegistry } from 'platform/api/module-loader';\n\nexport const BLOCK_TAGS: { [tagName: string]: string | boolean } = {\n  blockquote: true,\n  div: true,\n  h1: true,\n  h2: true,\n  h3: true,\n  h4: true,\n  h5: true,\n  h6: true,\n  p: true,\n  pre: true,\n  section: true,\n  table: true,\n  tbody: true,\n  td: true,\n  th: true,\n  thead: true,\n  tr: true,\n};\n\nexport const INLINE_TAGS: { [tagName: string]: string | boolean } = {\n  span: true,\n};\n\nexport const MARK_TAGS: { [tagName: string]: string | boolean } = {\n  a: true,\n  b: true,\n  code: true,\n  em: true,\n  i: true,\n  strong: true,\n  u: true,\n};\n\nconst SLATE_RULES: Rule[] = [\n  {\n    deserialize(el, next) {\n      if (el.nodeType === Node.TEXT_NODE && el.textContent.match(/^\\s*$/)) {\n        return null;\n      }\n      const tagName = el.tagName.toLowerCase();\n      const type = BLOCK_TAGS[tagName];\n      if (type) {\n        return {\n          object: 'block',\n          type: typeof type === 'string' ? type : tagName,\n          data: {\n            attributes: getAttributesAsReactProps(el),\n          },\n          nodes: next(el.childNodes),\n        };\n      }\n    },\n    serialize(obj, children): never {\n      throw new Error('block serialization is not supported');\n    },\n  },\n  {\n    deserialize(el, next) {\n      const tagName = el.tagName.toLowerCase();\n      const type = MARK_TAGS[tagName];\n      if (type) {\n        return {\n          object: 'mark',\n          type: typeof type === 'string' ? type : tagName,\n          data: {\n            attributes: getAttributesAsReactProps(el),\n          },\n          nodes: next(el.childNodes),\n        };\n      }\n    },\n    serialize(obj, children): never {\n      throw new Error('mark serialization is not supported');\n    },\n  },\n];\n\nfunction getAttributesAsReactProps(el: Element): { [key: string]: any } {\n  const data: { [key: string]: any } = {};\n  for (let i = 0; i < el.attributes.length; i++) {\n    const attr = el.attributes.item(i);\n    const parsedPropValue = attr.name === 'style' ? ModuleRegistry.parseReactStyleFromCss(attr.value) : attr.value;\n    data[attr.name] = parsedPropValue;\n  }\n  return data;\n}\n\nexport const SLATE_HTML = new Html({ rules: SLATE_RULES });\n"],"sourceRoot":""}